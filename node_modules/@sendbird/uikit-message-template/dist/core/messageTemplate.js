import React from 'react';
import { SizeContextProvider } from '../context/SizeProvider';
import { ComponentType } from '../types/components';
import { SUPPORTED_TEMPLATE_VERSIONS, isTemplateVersionSupported } from '../utils';
import { setTemplateItemId } from '../utils/templateItemId';
import { defaultProperties } from './defaultValues';
import { createParser } from './parser';
import { createRenderer } from './renderer';
export const createMessageTemplate = (opts) => {
    const Container = opts.Container || React.Fragment;
    const UnknownMessage = opts.UnknownMessage || (() => null);
    const parser = opts.parser || createParser();
    const renderer = opts.renderer || createRenderer();
    const MessageTemplateBase = ({ templateItems, templateVersion, parentLayout = defaultProperties.box.layout, depth = 0, }) => {
        if (!isTemplateVersionSupported(templateVersion)) {
            throw new Error(`Cannot parse template item due to unsupported template version: ${templateVersion}, ${SUPPORTED_TEMPLATE_VERSIONS}`);
        }
        return (React.createElement(React.Fragment, null, templateItems.map((rawItem, index, siblings) => {
            const result = parser.parse(rawItem, { parentLayout, depth, elemIdx: index, siblings });
            const item = result.transformed;
            const rendererProps = {
                key: index,
                siblings,
                parentLayout,
                parsedProperties: result.properties,
            };
            switch (item.type) {
                case ComponentType.Carousel: {
                    if (!Array.isArray(item.items) || item.items.length === 0) {
                        throw new Error('Cannot parse template item as Carousel if carousel has no items.');
                    }
                    return (React.createElement(renderer.carouselView, Object.assign({}, item, rendererProps), item.items.map((template, index) => (React.createElement(MessageTemplateBase, { key: index, templateItems: template.body.items || [], depth: depth + 1, templateVersion: template.version })))));
                }
                case ComponentType.Box: {
                    return (React.createElement(renderer.box, Object.assign({}, item, rendererProps),
                        React.createElement(MessageTemplateBase, { templateItems: item.items || [], parentLayout: item.layout, depth: depth + 1, templateVersion: templateVersion })));
                }
                case ComponentType.Text: {
                    return React.createElement(renderer.text, Object.assign({}, item, rendererProps));
                }
                case ComponentType.Image: {
                    return React.createElement(renderer.image, Object.assign({}, item, rendererProps));
                }
                case ComponentType.TextButton: {
                    return React.createElement(renderer.textButton, Object.assign({}, item, rendererProps));
                }
                case ComponentType.ImageButton: {
                    return React.createElement(renderer.imageButton, Object.assign({}, item, rendererProps));
                }
                default: {
                    // or throw new Error('Cannot parse template item')
                    return React.createElement(UnknownMessage, { item: item });
                }
            }
        })));
    };
    return {
        MessageTemplate: ({ templateVersion, templateItems, parentLayout = defaultProperties.rootLayout, }) => {
            const items = setTemplateItemId(templateItems);
            return (React.createElement(SizeContextProvider, null,
                React.createElement(Container, null,
                    React.createElement(MessageTemplateBase, { isRoot: true, parentLayout: parentLayout, templateItems: items, templateVersion: templateVersion }))));
        },
        MessageTemplateBase,
    };
};
