import React from 'react';

import { SizeContextProvider } from '../context/SizeProvider';
import { BasicProps, ComponentType, ComponentsUnion } from '../types/components';
import type { Layout } from '../types/styles';
import type { Template } from '../types/template';
import { SUPPORTED_TEMPLATE_VERSIONS, isTemplateVersionSupported } from '../utils';
import { setTemplateItemId } from '../utils/templateItemId';
import { defaultProperties } from './defaultValues';
import { Parser, createParser } from './parser';
import { Renderer, createRenderer } from './renderer';

interface ContainerProps extends React.PropsWithChildren<unknown> {
  className?: string;
}

interface MessageTemplateOptions<ParsedProperties> {
  parser?: Parser<ParsedProperties>;
  renderer?: Renderer<ParsedProperties>;
  Container?: (props: ContainerProps) => React.ReactElement;
  UnknownMessage?: (props: { item: ComponentsUnion['properties'] }) => React.ReactElement | null;
}

export interface MessageTemplateProps {
  /**
   * @description template items. ** IT IS NOT TRANSFORMED YET IN HERE **.
   * */
  templateItems: Template['body']['items'];
  templateVersion?: Template['version']; // Made optional for backward compatibility.
  parentLayout?: Layout;
  depth?: number;
  isRoot?: boolean;
}

export const createMessageTemplate = <T,>(opts: MessageTemplateOptions<T>) => {
  const Container = opts.Container || React.Fragment;
  const UnknownMessage = opts.UnknownMessage || (() => null);

  const parser = opts.parser || createParser<T>();
  const renderer = opts.renderer || createRenderer<T>();

  const MessageTemplateBase = ({
    templateItems,
    templateVersion,
    parentLayout = defaultProperties.box.layout,
    depth = 0,
  }: MessageTemplateProps) => {
    if (!isTemplateVersionSupported(templateVersion)) {
      throw new Error(
        `Cannot parse template item due to unsupported template version: ${templateVersion}, ${SUPPORTED_TEMPLATE_VERSIONS}`,
      );
    }

    return (
      <React.Fragment>
        {templateItems.map((rawItem, index, siblings) => {
          const result = parser.parse(rawItem, { parentLayout, depth, elemIdx: index, siblings });
          const item = result.transformed;

          const rendererProps: BasicProps<unknown, T> = {
            key: index,
            siblings,
            parentLayout,
            parsedProperties: result.properties,
          };

          switch (item.type) {
            case ComponentType.Carousel: {
              if (!Array.isArray(item.items) || item.items.length === 0) {
                throw new Error('Cannot parse template item as Carousel if carousel has no items.');
              }
              return (
                <renderer.carouselView {...item} {...rendererProps}>
                  {item.items.map((template, index) => (
                    <MessageTemplateBase
                      key={index}
                      templateItems={template.body.items || []}
                      depth={depth + 1}
                      templateVersion={template.version}
                    />
                  ))}
                </renderer.carouselView>
              );
            }

            case ComponentType.Box: {
              return (
                <renderer.box {...item} {...rendererProps}>
                  <MessageTemplateBase
                    templateItems={item.items || []}
                    parentLayout={item.layout}
                    depth={depth + 1}
                    templateVersion={templateVersion}
                  />
                </renderer.box>
              );
            }

            case ComponentType.Text: {
              return <renderer.text {...item} {...rendererProps} />;
            }

            case ComponentType.Image: {
              return <renderer.image {...item} {...rendererProps} />;
            }

            case ComponentType.TextButton: {
              return <renderer.textButton {...item} {...rendererProps} />;
            }

            case ComponentType.ImageButton: {
              return <renderer.imageButton {...item} {...rendererProps} />;
            }

            default: {
              // or throw new Error('Cannot parse template item')
              return <UnknownMessage item={item} />;
            }
          }
        })}
      </React.Fragment>
    );
  };

  return {
    MessageTemplate: ({
      templateVersion,
      templateItems,
      parentLayout = defaultProperties.rootLayout,
    }: MessageTemplateProps) => {
      const items = setTemplateItemId(templateItems);

      return (
        <SizeContextProvider>
          <Container>
            <MessageTemplateBase
              isRoot
              parentLayout={parentLayout}
              templateItems={items}
              templateVersion={templateVersion}
            />
          </Container>
        </SizeContextProvider>
      );
    },
    MessageTemplateBase,
  };
};
