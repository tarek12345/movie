// -------- Set property mapper
import {
  Box,
  type Carousel,
  ComponentType,
  ComponentsUnion,
  Image,
  ImageButton,
  Text,
  TextButton,
} from '../types/components';
import type { Layout } from '../types/styles';
import { colorTransform } from './transforms/colorTransform';
import { numberTransform } from './transforms/numberTransform';

export type ParserMapOptions = {
  parentLayout: Layout;
  depth?: number;
  elemIdx?: number;
  siblings?: Array<ComponentsUnion['properties']>;
};

/**
 * ParserTransform is a function that is called before parsing the component properties.
 * It performs preprocessing on specific component properties and then returns them.
 *
 * Caution: The returned property must always be a new immutable object.
 * Failing to adhere to this rule can affect the original property object, potentially leading to bugs.
 * For example, a transform that reverses a specific string must guarantee consistent results even if executed N times.
 * */
export type ParserTransform = {
  run: <T extends ComponentsUnion['properties'] = ComponentsUnion['properties']>(properties: T) => T;
};

interface CreateParserParams<ParsedProperties> {
  defaultMapper?(...args: any[]): any;
  mapBoxProps?(properties: Box, options: ParserMapOptions): ParsedProperties;
  mapTextProps?(properties: Text, options: ParserMapOptions): ParsedProperties;
  mapImageProps?(properties: Image, options: ParserMapOptions): ParsedProperties;
  mapTextButtonProps?(properties: TextButton, options: ParserMapOptions): ParsedProperties;
  mapImageButtonProps?(properties: ImageButton, options: ParserMapOptions): ParsedProperties;
  mapCarouselProps?(properties: Carousel, options: ParserMapOptions): ParsedProperties;
  transforms?: ParserTransform[];
}

export interface Parser<ParsedProperties> {
  parse<T extends ComponentsUnion['properties'] = ComponentsUnion['properties']>(
    properties: T,
    options: ParserMapOptions,
  ): {
    transformed: T;
    properties: ParsedProperties | undefined;
  };
  setTransforms(transforms: ParserTransform[]): void;
  addTransforms(transforms: ParserTransform[]): void;
}

const MAPPER: CreateParserParams<any>['defaultMapper'] = () => undefined;

export const createParser = <ParsedProperties = object | string>(
  params?: CreateParserParams<ParsedProperties>,
): Parser<ParsedProperties> => {
  const defaultMapper = params?.defaultMapper || MAPPER;
  const mapper: Omit<Required<CreateParserParams<ParsedProperties>>, 'transforms'> = {
    defaultMapper,
    mapBoxProps: params?.mapBoxProps || defaultMapper,
    mapTextProps: params?.mapTextProps || defaultMapper,
    mapImageProps: params?.mapImageProps || defaultMapper,
    mapTextButtonProps: params?.mapTextButtonProps || defaultMapper,
    mapImageButtonProps: params?.mapImageButtonProps || defaultMapper,
    mapCarouselProps: params?.mapCarouselProps || defaultMapper,
  };

  const transforms = [colorTransform, numberTransform, ...(params?.transforms ?? [])];
  const transformDirty = new Set<string>();

  return {
    setTransforms(newTransforms: ParserTransform[]) {
      transforms.length = 0;
      transforms.push(...newTransforms);
      transformDirty.clear();
    },
    addTransforms(newTransforms: ParserTransform[]) {
      transforms.push(...newTransforms);
    },
    parse(rawItem, options) {
      // Note: it is for mutable transforms
      // const uniqId =
      //   typeof options.depth === 'number' && typeof options.elemIdx === 'number'
      //     ? `id-${options.depth}-${options.elemIdx}`
      //     : rawItem.id ?? rawItem.elementId ?? JSON.stringify(rawItem);
      //
      // let item = rawItem;
      // if (!transformDirty.has(uniqId)) {
      //   item = transforms.reduce((it, transform) => transform(it), rawItem);
      //   transformDirty.add(uniqId);
      // }

      const item = transforms.reduce((it, transform) => transform.run(it), rawItem);

      switch (item.type) {
        case ComponentType.Box: {
          return { transformed: item, properties: mapper.mapBoxProps(item, options) };
        }
        case ComponentType.Text: {
          return { transformed: item, properties: mapper.mapTextProps(item, options) };
        }
        case ComponentType.Image: {
          return { transformed: item, properties: mapper.mapImageProps(item, options) };
        }
        case ComponentType.TextButton: {
          return { transformed: item, properties: mapper.mapTextButtonProps(item, options) };
        }
        case ComponentType.ImageButton: {
          return { transformed: item, properties: mapper.mapImageButtonProps(item, options) };
        }
        case ComponentType.Carousel: {
          return { transformed: item, properties: mapper.mapCarouselProps(item, options) };
        }
        default:
          return { transformed: item, properties: undefined };
      }
    },
  };
};

// -------- Default values
interface ByAppearance<T> {
  light: T;
  dark: T;
}

interface DefaultStyle {
  _: undefined;
}

export const DEFAULT_PARSER_VALUES: ByAppearance<DefaultStyle> = {
  light: { _: undefined },
  dark: { _: undefined },
};
