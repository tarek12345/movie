import {
  type Carousel,
  ComponentType,
  type Image,
  type ImageButton,
  type Text,
  type TextButton,
  type View,
} from '../../types/components.js';
import type {
  CarouselStyle,
  ImageMetaData,
  Margin,
  Padding,
  SizeSpec,
  TextStyle,
  ViewStyle,
} from '../../types/styles.js';
import type { ParserTransform } from '../parser';

const isNumber = (val?: unknown): val is number | string => {
  if (typeof val === 'string') {
    return !Number.isNaN(Number(val));
  }
  return typeof val === 'number' && !Number.isNaN(val);
};

const outSingle = <T extends object, K extends keyof T>(key: K, obj: T) => {
  if (obj[key] === undefined || obj[key] === null) return {};
  return isNumber(obj[key]) ? { [key]: Number(obj[key]) } : {};
};

const outSpacing = (key: 'margin' | 'padding', spacing?: Margin | Padding) => {
  if (!spacing) return {};
  return {
    [key]: {
      left: isNumber(spacing.left) ? Number(spacing.left) : spacing.left,
      right: isNumber(spacing.right) ? Number(spacing.right) : spacing.right,
      top: isNumber(spacing.top) ? Number(spacing.top) : spacing.top,
      bottom: isNumber(spacing.bottom) ? Number(spacing.bottom) : spacing.bottom,
    },
  };
};
const outSize = (key: 'width' | 'height', size?: SizeSpec) => {
  if (!size) return {};
  return {
    [key]: {
      type: size.type,
      value: isNumber(size.value) ? Number(size.value) : size.value,
    },
  };
};
const outMetadata = (metaData?: ImageMetaData) => {
  if (!metaData) return {};
  return {
    metaData: {
      pixelWidth: isNumber(metaData.pixelWidth) ? Number(metaData.pixelWidth) : metaData.pixelWidth,
      pixelHeight: isNumber(metaData.pixelHeight) ? Number(metaData.pixelHeight) : metaData.pixelHeight,
    },
  };
};

const outViewStyle = (viewStyle?: ViewStyle) => {
  if (!viewStyle) return {};
  return {
    viewStyle: {
      ...viewStyle,
      ...outSingle('borderWidth', viewStyle),
      ...outSingle('radius', viewStyle),
      ...outSpacing('margin', viewStyle.margin),
      ...outSpacing('padding', viewStyle.padding),
    } satisfies ViewStyle,
  };
};
const outTextStyle = (textStyle?: TextStyle) => {
  if (!textStyle) return {};
  return {
    textStyle: {
      ...textStyle,
      ...outSingle('size', textStyle),
      ...outSingle('weight', textStyle),
    } satisfies TextStyle,
  };
};
const outCarouselStyle = (carouselstyle?: CarouselStyle) => {
  if (!carouselstyle) return {};
  return {
    carouselStyle: {
      ...carouselstyle,
      ...outSingle('spacing', carouselstyle),
    } satisfies CarouselStyle,
  };
};

const outViewProps = (view: View) => {
  return {
    ...outSize('width', view.width),
    ...outSize('height', view.height),
    ...outViewStyle(view.viewStyle),
  } satisfies Partial<View>;
};
const outTextProps = (text: Text | TextButton) => {
  return {
    ...outViewProps(text),
    ...outTextStyle(text.textStyle),
    ...outSingle('maxTextLines', text),
  } satisfies Partial<Text | TextButton>;
};
const outImageProps = (image: Image | ImageButton) => {
  return {
    ...outViewProps(image),
    ...outMetadata(image.metaData),
  } satisfies Partial<Image | ImageButton>;
};
const outCarouselProps = (carousel: Carousel) => {
  return {
    ...outViewProps(carousel),
    ...outCarouselStyle(carousel.carouselStyle),
    // Convert only top-level items to find has fill width values.
    items: carousel.items.map((item) => ({
      ...item,
      body: { ...item.body, items: item.body.items.map((it) => numberTransform.run(it)) },
    })),
  } satisfies Partial<Carousel>;
};

export const numberTransform: ParserTransform = {
  run(prop) {
    if (prop.type === ComponentType.Text || prop.type === ComponentType.TextButton) {
      return { ...prop, ...outTextProps(prop) };
    }

    if (prop.type === ComponentType.ImageButton || prop.type === ComponentType.Image) {
      return { ...prop, ...outImageProps(prop) };
    }

    if (prop.type === ComponentType.Carousel) {
      return { ...prop, ...outCarouselProps(prop) };
    }

    return { ...prop, ...outViewProps(prop) };
  },
};
