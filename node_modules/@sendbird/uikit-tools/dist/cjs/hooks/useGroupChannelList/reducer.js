"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useGroupChannelListReducer = void 0;
const react_1 = require("react");
const defaultReducer = (_a, action) => {
    var draft = __rest(_a, []);
    const compareByOrder = createCompareByOrder(draft.order);
    switch (action.type) {
        case 'update_refreshing': {
            draft.refreshing = action.value.status;
            break;
        }
        case 'update_initialized': {
            draft.initialized = action.value.status;
            break;
        }
        case 'update_channels': {
            getGroupChannels(action.value.channels).forEach((freshChannel) => {
                const idx = draft.groupChannels.findIndex((staleChannel) => staleChannel.url === freshChannel.url);
                if (idx > -1)
                    draft.groupChannels[idx] = freshChannel;
            });
            compareByOrder && (draft.groupChannels = draft.groupChannels.sort(compareByOrder));
            break;
        }
        case 'delete_channels': {
            action.value.channelUrls.forEach((url) => {
                const idx = draft.groupChannels.findIndex((c) => c.url === url);
                if (idx > -1)
                    draft.groupChannels.splice(idx, 1);
            });
            compareByOrder && (draft.groupChannels = draft.groupChannels.sort(compareByOrder));
            break;
        }
        case 'append_channels': {
            const groupChannels = getGroupChannels(action.value.channels);
            if (action.value.clearBeforeAction) {
                draft.groupChannels = groupChannels;
            }
            else {
                draft.groupChannels = mergeObjectArrays(draft.groupChannels, groupChannels, 'url');
            }
            compareByOrder && (draft.groupChannels = draft.groupChannels.sort(compareByOrder));
            break;
        }
        case 'update_order': {
            draft.order = action.value.order;
            const compareByOrder = createCompareByOrder(draft.order);
            compareByOrder && (draft.groupChannels = draft.groupChannels.sort(compareByOrder));
            break;
        }
    }
    return draft;
};
const useGroupChannelListReducer = (order) => {
    const [{ initialized, refreshing, groupChannels }, dispatch] = (0, react_1.useReducer)(defaultReducer, {
        initialized: false,
        refreshing: false,
        groupChannels: [],
        order,
    });
    const updateChannels = (channels) => {
        dispatch({ type: 'update_channels', value: { channels } });
    };
    const deleteChannels = (channelUrls) => {
        dispatch({ type: 'delete_channels', value: { channelUrls } });
    };
    const appendChannels = (channels, clearBeforeAction) => {
        dispatch({ type: 'append_channels', value: { channels, clearBeforeAction } });
    };
    const updateInitialized = (status) => {
        dispatch({ type: 'update_initialized', value: { status } });
    };
    const updateRefreshing = (status) => {
        dispatch({ type: 'update_refreshing', value: { status } });
    };
    const updateOrder = (order) => {
        dispatch({ type: 'update_order', value: { order } });
    };
    return {
        updateInitialized,
        updateRefreshing,
        updateChannels,
        deleteChannels,
        appendChannels,
        updateOrder,
        initialized,
        refreshing,
        groupChannels,
    };
};
exports.useGroupChannelListReducer = useGroupChannelListReducer;
const createCompareByOrder = (order) => {
    if (!order)
        return undefined;
    return (channel1, channel2) => {
        switch (order) {
            case 'latest_last_message': {
                if (channel1.lastMessage && channel2.lastMessage) {
                    return channel2.lastMessage.createdAt - channel1.lastMessage.createdAt;
                }
                else if (channel1.lastMessage) {
                    return -1;
                }
                else if (channel2.lastMessage) {
                    return 1;
                }
                else {
                    return channel2.createdAt - channel1.createdAt;
                }
            }
            case 'chronological': {
                return channel2.createdAt - channel1.createdAt;
            }
            case 'channel_name_alphabetical': {
                return channel1.name.localeCompare(channel2.name);
            }
            default: {
                return 0;
            }
        }
    };
};
function mergeObjectArrays(A, B, key) {
    const uniqueValues = new Set(A.map((obj) => obj[key]));
    const newArr = [...A];
    for (let i = 0; i < B.length; i++) {
        if (!uniqueValues.has(B[i][key])) {
            newArr.push(B[i]);
            uniqueValues.add(B[i][key]);
        }
    }
    return newArr;
}
function getGroupChannels(channels) {
    return channels.filter((it) => it.isGroupChannel());
}
