"use strict";
// NOTE: type guard fix for optional chaining - https://github.com/microsoft/TypeScript/pull/55613
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameType = exports.isNotEmptyArray = exports.isSet = exports.isOneOf = exports.isBoolean = void 0;
function isBoolean(val) {
    return typeof val === 'boolean';
}
exports.isBoolean = isBoolean;
function isOneOf(val, values) {
    return values.includes(val);
}
exports.isOneOf = isOneOf;
function isSet(val) {
    return val instanceof Set;
}
exports.isSet = isSet;
function isNotEmptyArray(arr) {
    if (!arr || !Array.isArray(arr))
        return false;
    return arr.length !== 0;
}
exports.isNotEmptyArray = isNotEmptyArray;
function isSameType(a, b) {
    // we do this cause typeof can't differenciate object/ array/ null
    return Object.prototype.toString.call(a) === Object.prototype.toString.call(b);
}
exports.isSameType = isSameType;
