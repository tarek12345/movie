import { type SendbirdChatWith } from '@sendbird/chat';
import type { GroupChannel, GroupChannelModule, MessageCollection, MessageCollectionParams, MessageFilterParams } from '@sendbird/chat/groupChannel';
import type { BaseMessage, FileMessage, FileMessageCreateParams, FileMessageUpdateParams, MultipleFilesMessage, MultipleFilesMessageCreateParams, ReplyType, UserMessage, UserMessageCreateParams, UserMessageUpdateParams } from '@sendbird/chat/message';
import type { SendbirdMessage } from '../../types.js';
type Log = (...args: unknown[]) => void;
type CollectionCreatorBasicParams = Omit<MessageCollectionParams, 'filter'> & Pick<MessageFilterParams, 'replyType'>;
type UseGroupChannelMessagesOptions = {
    replyType?: ReplyType;
    startingPoint?: number;
    markAsRead?: (channels: GroupChannel[]) => void;
    shouldCountNewMessages?: () => boolean;
    collectionCreator?: (basicParams?: CollectionCreatorBasicParams) => MessageCollection;
    sortComparator?: (a: SendbirdMessage, b: SendbirdMessage) => number;
    onMessagesReceived?: (messages: SendbirdMessage[]) => void;
    onMessagesUpdated?: (messages: SendbirdMessage[]) => void;
    onChannelDeleted?: (channelUrl: string) => void;
    onChannelUpdated?: (channel: GroupChannel) => void;
    onCurrentUserBanned?: () => void;
    logger?: {
        info?: Log;
        warn?: Log;
        error?: Log;
        log?: Log;
        debug?: Log;
    };
};
/**
 * group channel messages hook
 * - Receive new messages from other users & should count new messages -> append to state(newMessages)
 * - onTopReached -> prev() -> fetch prev messages and append to state(messages)
 * - onBottomReached -> next() -> fetch next messages and append to state(messages)
 * */
export declare const useGroupChannelMessages: (sdk: SendbirdChatWith<[GroupChannelModule]>, channel: GroupChannel, options?: UseGroupChannelMessagesOptions) => {
    /**
     * Initialized state, only available on first render
     * */
    initialized: boolean;
    /**
     * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.
     * */
    loading: boolean;
    /**
     * Refreshing state, status is changes when the refresh is called.
     * */
    refreshing: boolean;
    /**
     * Get messages, this state is for render
     * For example, if a user receives a new messages while searching for an old message
     * for this case, new messages will be included here.
     * */
    messages: BaseMessage[];
    /**
     * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.
     * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)
     *
     * A new message means a message that meets the below conditions
     * - Not admin message
     * - Not updated message
     * - Not current user's message
     * */
    newMessages: BaseMessage[];
    /**
     * Reset new message list
     * @return {void}
     * */
    resetNewMessages: () => void;
    /**
     * Reset message list and create a new collection for latest messages
     * @return {Promise<void>}
     * */
    refresh: () => Promise<void>;
    /**
     * Load previous messages to state
     * @return {Promise<void>}
     * */
    loadPrevious: () => Promise<void>;
    /**
     * Check if there are more previous messages to fetch
     * @return {boolean}
     * */
    hasPrevious: () => boolean;
    /**
     * Load next messages to state
     * @return {Promise<void>}
     * */
    loadNext: () => Promise<void>;
    /**
     * Check if there are more next messages to fetch
     * @return {boolean}
     * */
    hasNext: () => boolean;
    /**
     * Send user message
     * @param {UserMessageCreateParams} params user message create params
     * @param {function} [onPending] pending message callback
     * @return {Promise<UserMessage>} succeeded message
     * */
    sendUserMessage: (params: UserMessageCreateParams, onPending: (message: UserMessage) => void) => Promise<UserMessage>;
    /**
     * Send file message
     * @param {FileMessageCreateParams} params file message create params
     * @param {function} [onPending] pending message callback
     * @return {Promise<FileMessage>} succeeded message
     * */
    sendFileMessage: (params: FileMessageCreateParams, onPending?: ((message: FileMessage) => void) | undefined) => Promise<FileMessage>;
    /**
     * Send file messages
     * @param {FileMessageCreateParams[]} paramList file message create params
     * @param {function} [onPending] pending message callback for each message request
     * @return {Promise<FileMessage[]>} succeeded or failed message
     * */
    sendFileMessages: (paramsList: FileMessageCreateParams[], onPending?: ((message: FileMessage) => void) | undefined) => Promise<FileMessage[]>;
    /**
     * Send multiple files message
     * @param {MultipleFilesMessageCreateParams} params multiple files message create params
     * @param {function} [onPending] pending message callback
     * @return {Promise<MultipleFilesMessage>} succeeded message
     * */
    sendMultipleFilesMessage: (params: MultipleFilesMessageCreateParams, onPending?: ((message: MultipleFilesMessage) => void) | undefined) => Promise<MultipleFilesMessage>;
    /**
     * Update user message
     * @param {number} messageId
     * @param {UserMessageUpdateParams} params user message update params
     * @return {Promise<UserMessage>}
     * */
    updateUserMessage: (messageId: number, params: UserMessageUpdateParams) => Promise<UserMessage>;
    /**
     * Update file message
     * @param {number} messageId
     * @param {FileMessageUpdateParams} params file message update params
     * @return {Promise<FileMessage>}
     * */
    updateFileMessage: (messageId: number, params: FileMessageUpdateParams) => Promise<FileMessage>;
    /**
     * Resend failed message
     * @template {UserMessage | FileMessage | MultipleFilesMessage} T
     * @param {T} failedMessage message to resend
     * @return {Promise<T>}
     * */
    resendMessage: <T extends UserMessage | MultipleFilesMessage | FileMessage>(failedMessage: T) => Promise<T>;
    /**
     * Delete a message
     * @template {UserMessage | FileMessage | MultipleFilesMessage} T
     * @param {T} message succeeded or failed message
     * @return {Promise<void>}
     * */
    deleteMessage: <T_1 extends UserMessage | MultipleFilesMessage | FileMessage>(message: T_1) => Promise<void>;
    /**
     * Reset message list and create a new collection with starting point
     * @param {number} startingPoint
     * @param {function} callback
     * @return {void}
     * */
    resetWithStartingPoint: (startingPoint: number) => Promise<void>;
    /**
     * Do not use this api
     * */
    _dangerous_reducer_updateMessages: (messages: BaseMessage[], clearBeforeAction: boolean, currentUserId?: string | undefined) => void;
    /**
     * Do not use this api
     * */
    _dangerous_reducer_deleteMessages: (messageIds: number[], reqIds: string[]) => void;
};
export {};
