var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { useMemo, useReducer } from 'react';
import { SendingStatus } from '@sendbird/chat/message';
import { getMessageUniqId, isMyMessage, isNewMessage, isSendableMessage } from '../../utils/message.js';
export function arrayToMapWithGetter(arr, getSelector) {
    return arr.reduce((accum, curr) => {
        const _key = getSelector(curr);
        accum[_key] = curr;
        return accum;
    }, {});
}
const defaultReducer = (_a, action) => {
    var draft = __rest(_a, []);
    switch (action.type) {
        case 'update_initialized': {
            draft['initialized'] = action.value.status;
            return draft;
        }
        case 'update_refreshing': {
            draft['refreshing'] = action.value.status;
            return draft;
        }
        case 'update_loading': {
            draft['loading'] = action.value.status;
            return draft;
        }
        case 'update_has_previous': {
            draft['hasPreviousMessages'] = action.value.status;
            return draft;
        }
        case 'update_has_next': {
            draft['hasNextMessages'] = action.value.status;
            return draft;
        }
        case 'update_messages': {
            const userId = action.value.currentUserId;
            if (action.value.clearBeforeAction) {
                draft['messageMap'] = messagesToObject(action.value.messages);
            }
            else {
                // Filtering meaningless message updates
                const nextMessages = action.value.messages.filter((next) => {
                    var _a;
                    if (isMyMessage(next, userId)) {
                        const prev = (_a = draft['messageMap'][next.reqId]) !== null && _a !== void 0 ? _a : draft['messageMap'][next.messageId];
                        if (isMyMessage(prev, userId)) {
                            const shouldUpdate = shouldUpdateMessage(prev, next);
                            if (shouldUpdate) {
                                // Remove existing messages before update to prevent duplicate display
                                delete draft['messageMap'][prev.reqId];
                                delete draft['messageMap'][prev.messageId];
                            }
                            return shouldUpdate;
                        }
                    }
                    return true;
                });
                const obj = messagesToObject(nextMessages);
                draft['messageMap'] = Object.assign(Object.assign({}, draft['messageMap']), obj);
            }
            return draft;
        }
        case 'update_new_messages': {
            const userId = action.value.currentUserId;
            const newMessages = action.value.messages.filter((it) => isNewMessage(it, userId));
            if (action.value.clearBeforeAction) {
                draft['newMessageMap'] = arrayToMapWithGetter(newMessages, getMessageUniqId);
            }
            else {
                // Remove existing messages before update to prevent duplicate display
                const messageKeys = newMessages.map((it) => it.messageId);
                messageKeys.forEach((key) => delete draft['newMessageMap'][key]);
                draft['newMessageMap'] = Object.assign(Object.assign({}, draft['newMessageMap']), arrayToMapWithGetter(newMessages, getMessageUniqId));
            }
            return draft;
        }
        case 'delete_messages':
        case 'delete_new_messages': {
            const key = action.type === 'delete_messages' ? 'messageMap' : 'newMessageMap';
            draft[key] = Object.assign({}, draft[key]);
            action.value.messageIds.forEach((msgId) => {
                const message = draft[key][msgId];
                if (message) {
                    if (isSendableMessage(message))
                        delete draft[key][message.reqId];
                    delete draft[key][message.messageId];
                }
            });
            action.value.reqIds.forEach((reqId) => {
                const message = draft[key][reqId];
                if (message) {
                    if (isSendableMessage(message))
                        delete draft[key][message.reqId];
                    delete draft[key][message.messageId];
                }
            });
            return draft;
        }
    }
};
const messagesToObject = (messages) => {
    return messages.reduce((accum, curr) => {
        if (isSendableMessage(curr)) {
            accum[curr.reqId] = curr;
            if (curr.sendingStatus === SendingStatus.SUCCEEDED) {
                accum[curr.messageId] = curr;
            }
        }
        else {
            accum[curr.messageId] = curr;
        }
        return accum;
    }, {});
};
const shouldUpdateMessage = (prev, next) => {
    // message data update (e.g. reactions)
    if (prev.sendingStatus === SendingStatus.SUCCEEDED)
        return next.sendingStatus === SendingStatus.SUCCEEDED;
    // message sending status update
    return prev.sendingStatus !== next.sendingStatus;
};
const getOldestMessageTimeStamp = (messages) => {
    return messages.reduce((accum, curr) => {
        return Math.min(accum, curr.createdAt);
    }, Number.MAX_SAFE_INTEGER);
};
const getLatestMessageTimeStamp = (messages) => {
    return messages.reduce((accum, curr) => {
        return Math.max(accum, curr.createdAt);
    }, Number.MIN_SAFE_INTEGER);
};
export const useChannelThreadMessagesReducer = (sortComparator = defaultMessageComparator) => {
    const [{ initialized, loading, refreshing, hasPreviousMessages, hasNextMessages, messageMap, newMessageMap }, dispatch,] = useReducer(defaultReducer, {
        initialized: false,
        loading: true,
        refreshing: false,
        hasPreviousMessages: false,
        hasNextMessages: false,
        messageMap: {},
        newMessageMap: {},
    });
    const updateMessages = (messages, clearBeforeAction, currentUserId) => {
        dispatch({ type: 'update_messages', value: { messages, clearBeforeAction, currentUserId } });
    };
    const deleteMessages = (messageIds, reqIds) => {
        dispatch({ type: 'delete_messages', value: { messageIds, reqIds } });
    };
    const updateNewMessages = (messages, clearBeforeAction, currentUserId) => {
        dispatch({ type: 'update_new_messages', value: { messages, clearBeforeAction, currentUserId } });
    };
    const deleteNewMessages = (messageIds, reqIds) => {
        dispatch({ type: 'delete_new_messages', value: { messageIds, reqIds } });
    };
    const updateInitialized = (status) => {
        dispatch({ type: 'update_initialized', value: { status } });
    };
    const updateLoading = (status) => {
        dispatch({ type: 'update_loading', value: { status } });
    };
    const updateRefreshing = (status) => {
        dispatch({ type: 'update_refreshing', value: { status } });
    };
    const updateHasPreviousMessages = (status) => {
        dispatch({ type: 'update_has_previous', value: { status } });
    };
    const updateHasNextMessages = (status) => {
        dispatch({ type: 'update_has_next', value: { status } });
    };
    const newMessages = Object.values(newMessageMap);
    const messages = useMemo(() => Array.from(new Set(Object.values(messageMap))).sort(sortComparator), [messageMap]);
    const oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);
    const latestMessageTimeStamp = getLatestMessageTimeStamp(messages);
    return {
        updateInitialized,
        updateLoading,
        updateRefreshing,
        updateMessages,
        deleteMessages,
        updateHasPreviousMessages,
        updateHasNextMessages,
        initialized,
        loading,
        refreshing,
        hasPreviousMessages,
        hasNextMessages,
        oldestMessageTimeStamp,
        latestMessageTimeStamp,
        messages,
        newMessages,
        updateNewMessages,
        deleteNewMessages,
    };
};
const LARGE_OFFSET = Math.floor(Number.MAX_SAFE_INTEGER / 10);
export function defaultMessageComparator(a, b) {
    let aStatusOffset = 0;
    let bStatusOffset = 0;
    if (isSendableMessage(a) && a.sendingStatus !== 'succeeded')
        aStatusOffset = LARGE_OFFSET;
    if (isSendableMessage(b) && b.sendingStatus !== 'succeeded')
        bStatusOffset = LARGE_OFFSET;
    return a.createdAt + aStatusOffset - (b.createdAt + bStatusOffset);
}
