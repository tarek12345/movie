var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { useEffect, useLayoutEffect, useRef } from 'react';
import { CollectionEventSource } from '@sendbird/chat';
import { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';
import { ReplyType } from '@sendbird/chat/message';
import { sbuConstants } from '../../constants/sbuConstants.js';
import { isDifferentChannel } from '../../utils/channel.js';
import { isMyMessage, isSendableMessage } from '../../utils/message.js';
import { isNotEmptyArray } from '../../utils/validators.js';
import { useAsyncEffect } from '../useAsyncEffect.js';
import { useForceUpdate } from '../useForceUpdate.js';
import { useGroupChannelHandler } from '../useGroupChannelHandler.js';
import { usePreservedCallback } from '../usePreservedCallback.js';
import { useChannelThreadMessagesReducer } from './reducer.js';
function isThreadedMessage(message, parentMessage) {
    return message.parentMessageId === parentMessage.messageId;
}
export const useGroupChannelThreadMessages = (sdk, channel, parentMessage, options = {}) => {
    var _a, _b, _c, _d, _e;
    const internalOptions = useRef(options); // to keep reference of options in event handler
    internalOptions.current = options;
    const channelRef = useRef(channel); // to keep reference of channel in event handler
    channelRef.current = channel;
    const parentMessageRef = useRef(parentMessage); // to keep reference of parent message in event handler
    parentMessageRef.current = parentMessage;
    const startingPoint = useRef(((_a = internalOptions.current) === null || _a === void 0 ? void 0 : _a.startingPoint) || Number.MAX_SAFE_INTEGER);
    startingPoint.current = ((_b = internalOptions.current) === null || _b === void 0 ? void 0 : _b.startingPoint) || Number.MAX_SAFE_INTEGER;
    const prevFetchSize = sbuConstants.collection.message.defaultLimit.prev;
    const nextFetchSize = sbuConstants.collection.message.defaultLimit.next;
    const logger = internalOptions.current.logger;
    const isFetching = useRef({ prev: false, next: false });
    const forceUpdate = useForceUpdate();
    const collectionRef = useRef({
        initialized: false,
        apiInitialized: false,
        instance: null,
    });
    const { initialized, loading, refreshing, hasPreviousMessages, hasNextMessages, oldestMessageTimeStamp, latestMessageTimeStamp, messages, newMessages, updateMessages, updateNewMessages, deleteNewMessages, deleteMessages, updateInitialized, updateLoading, updateRefreshing, updateHasPreviousMessages, updateHasNextMessages, } = useChannelThreadMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);
    const markAsReadBySource = usePreservedCallback((source) => {
        var _a, _b, _c, _d;
        if (!channelRef.current || !channelRef.current.url) {
            return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');
        }
        try {
            switch (source) {
                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:
                case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:
                case CollectionEventSource.SYNC_MESSAGE_FILL:
                case undefined:
                    (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);
                    break;
            }
        }
        catch (e) {
            (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelThreadMessages/markAsReadBySource]', e);
        }
    });
    const updateNewMessagesReceived = usePreservedCallback((source, messages) => {
        var _a, _b, _c, _d, _e;
        const incomingMessages = messages.filter((it) => { var _a; return isThreadedMessage(it, parentMessageRef.current) && !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId); });
        if (incomingMessages.length > 0) {
            switch (source) {
                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:
                case CollectionEventSource.SYNC_MESSAGE_FILL: {
                    if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {
                        updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
                    }
                    (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);
                    break;
                }
            }
        }
    });
    useAsyncEffect(() => __awaiter(void 0, void 0, void 0, function* () {
        var _f, _g, _h, _j, _k;
        const messages = yield ((_f = channelRef.current) === null || _f === void 0 ? void 0 : _f.getMessagesByMessageId((_g = parentMessageRef.current) === null || _g === void 0 ? void 0 : _g.messageId, {
            prevResultSize: 1,
            nextResultSize: 1,
            isInclusive: true,
            includeThreadInfo: true,
            includeMetaArray: true,
            includeReactions: (_h = internalOptions.current.isReactionEnabled) !== null && _h !== void 0 ? _h : false,
        }));
        const parentMessage = messages === null || messages === void 0 ? void 0 : messages.find((message) => {
            return message.messageId === parentMessageRef.current.messageId;
        });
        if (parentMessage) {
            parentMessageRef.current = parentMessage;
            (_k = (_j = internalOptions.current).onParentMessageUpdated) === null || _k === void 0 ? void 0 : _k.call(_j, parentMessage);
        }
    }), [(_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.isReactionEnabled]);
    const init = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {
        return new Promise((resolve) => {
            var _a, _b, _c;
            if (!channelRef.current || !channelRef.current.url) {
                return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');
            }
            if (!parentMessageRef.current) {
                return (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages] parent message is required');
            }
            if (collectionRef.current.instance)
                collectionRef.current.instance.dispose();
            markAsReadBySource();
            updateNewMessages([], true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
            const updateUnsentMessages = () => {
                var _a, _b;
                const { pendingMessages, failedMessages } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};
                let filteredMessages;
                if (isNotEmptyArray(pendingMessages)) {
                    filteredMessages = pendingMessages.filter((message) => isThreadedMessage(message, parentMessageRef.current));
                }
                if (isNotEmptyArray(failedMessages)) {
                    filteredMessages = failedMessages.filter((message) => isThreadedMessage(message, parentMessageRef.current));
                }
                if (isNotEmptyArray(filteredMessages))
                    updateMessages(filteredMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);
            };
            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
                var _d, _e, _f, _g;
                try {
                    if (parentMessageRef.current) {
                        const params = {
                            prevResultSize: prevFetchSize,
                            nextResultSize: nextFetchSize,
                            isInclusive: true,
                            includeMetaArray: true,
                            includeReactions: (_d = internalOptions.current.isReactionEnabled) !== null && _d !== void 0 ? _d : false,
                        };
                        const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(startingPoint, params);
                        if (isNotEmptyArray(threadedMessages)) {
                            const prevMessagesCount = threadedMessages.filter((message) => message.createdAt < startingPoint).length;
                            const nextMessagesCount = threadedMessages.filter((message) => message.createdAt > startingPoint).length;
                            updateHasPreviousMessages(prevMessagesCount >= prevFetchSize);
                            updateHasNextMessages(nextMessagesCount >= nextFetchSize);
                            updateMessages(threadedMessages, true, (_e = sdk.currentUser) === null || _e === void 0 ? void 0 : _e.userId);
                        }
                    }
                    else {
                        (_f = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _f === void 0 ? void 0 : _f.call(logger, '[useGroupChannelThreadMessages] parent message is required');
                    }
                    resolve();
                }
                catch (error) {
                    (_g = logger === null || logger === void 0 ? void 0 : logger.error) === null || _g === void 0 ? void 0 : _g.call(logger, '[useGroupChannelThreadMessages] Initialize thread list failed.', error);
                }
            }));
            const collectionInstance = channelRef.current.createMessageCollection({
                prevResultLimit: prevFetchSize,
                nextResultLimit: nextFetchSize,
                startingPoint: startingPoint - 1,
                filter: new MessageFilter({ replyType: ReplyType.ALL }),
            });
            collectionRef.current = { apiInitialized: false, initialized: false, instance: collectionInstance };
            collectionInstance.setMessageCollectionHandler({
                onMessagesAdded: (ctx, __, messages) => {
                    var _a;
                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));
                    if (isNotEmptyArray(filteredMessages)) {
                        markAsReadBySource(ctx.source);
                        updateNewMessagesReceived(ctx.source, filteredMessages);
                        updateMessages(filteredMessages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                    }
                },
                onMessagesUpdated: (ctx, __, messages) => {
                    var _a, _b, _c, _d, _e;
                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));
                    const parentMessage = messages.find((message) => message.messageId === parentMessageRef.current.messageId);
                    if (parentMessage) {
                        parentMessageRef.current = parentMessage;
                        (_b = (_a = internalOptions.current).onParentMessageUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, parentMessage);
                    }
                    if (isNotEmptyArray(filteredMessages)) {
                        markAsReadBySource(ctx.source);
                        updateNewMessagesReceived(ctx.source, filteredMessages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.
                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
                        if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {
                            (_e = (_d = internalOptions.current).onMessagesUpdated) === null || _e === void 0 ? void 0 : _e.call(_d, filteredMessages);
                        }
                    }
                },
                onMessagesDeleted: (_, __, ___, messages) => {
                    var _a, _b;
                    const parentMessage = messages.find((message) => message.messageId === parentMessageRef.current.messageId);
                    if (parentMessage) {
                        (_b = (_a = internalOptions.current).onParentMessageDeleted) === null || _b === void 0 ? void 0 : _b.call(_a);
                    }
                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));
                    if (isNotEmptyArray(filteredMessages)) {
                        const msgIds = filteredMessages.map((it) => it.messageId);
                        const reqIds = filteredMessages.filter(isSendableMessage).map((it) => it.reqId);
                        deleteMessages(msgIds, reqIds);
                        deleteNewMessages(msgIds, reqIds);
                    }
                },
                onChannelDeleted: (_, channelUrl) => {
                    var _a, _b;
                    (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);
                },
                onChannelUpdated: (_, channel) => {
                    var _a, _b;
                    forceUpdate();
                    (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);
                },
                onHugeGapDetected: () => {
                    init(startingPoint);
                },
            });
            collectionInstance
                .initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API)
                .onCacheResult((err, messages) => {
                var _a, _b, _c;
                if (err) {
                    sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', err));
                }
                else if (messages) {
                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', 'message length:', messages.length);
                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));
                    if (isNotEmptyArray(filteredMessages)) {
                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
                        updateUnsentMessages();
                    }
                }
            })
                .onApiResult((err, messages) => {
                var _a, _b, _c;
                if (err) {
                    (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onApiResult]', err);
                }
                else if (messages) {
                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onApiResult]', 'message length:', messages.length);
                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));
                    if (isNotEmptyArray(filteredMessages)) {
                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
                        if (sdk.isCacheEnabled)
                            updateUnsentMessages();
                    }
                }
                collectionRef.current.initialized = true;
                collectionRef.current.apiInitialized = true;
            });
        });
    }));
    useGroupChannelHandler(sdk, {
        onUserBanned(eventChannel, bannedUser) {
            var _a, _b, _c;
            if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {
                if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {
                    (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);
                }
                else {
                    forceUpdate();
                }
            }
        },
    });
    useLayoutEffect(() => {
        const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
            if (sdk.currentUser && channelRef.current) {
                updateInitialized(false);
                updateLoading(true);
                yield init(startingPoint.current);
                updateLoading(false);
                updateInitialized(true);
            }
        }));
        return () => clearTimeout(timeout);
    }, [sdk, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId, (_e = channelRef.current) === null || _e === void 0 ? void 0 : _e.url, startingPoint.current]);
    useEffect(() => {
        return () => {
            if (collectionRef.current.instance)
                collectionRef.current.instance.dispose();
        };
    }, []);
    const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        if (sdk.currentUser && channelRef.current) {
            updateRefreshing(true);
            yield init(startingPoint.current);
            updateRefreshing(false);
        }
    }));
    const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        var _l, _m, _o, _p;
        if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {
            (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');
            return;
        }
        if (hasPreviousMessages && !isFetching.current.prev) {
            try {
                isFetching.current.prev = true;
                const params = {
                    prevResultSize: prevFetchSize,
                    nextResultSize: 0,
                    isInclusive: false,
                    includeReactions: (_m = internalOptions.current.isReactionEnabled) !== null && _m !== void 0 ? _m : false,
                };
                const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(oldestMessageTimeStamp, params);
                if (isNotEmptyArray(threadedMessages)) {
                    updateHasPreviousMessages(threadedMessages.length >= prevFetchSize);
                    updateMessages(threadedMessages, false, (_o = sdk.currentUser) === null || _o === void 0 ? void 0 : _o.userId);
                }
            }
            catch (error) {
                (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelThreadMessages] loadPrevious thread list failed.', error);
            }
            finally {
                isFetching.current.prev = false;
            }
        }
    }));
    const hasPrevious = usePreservedCallback(() => {
        return hasPreviousMessages;
    });
    const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        var _q, _r, _s, _t;
        if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {
            (_q = logger === null || logger === void 0 ? void 0 : logger.error) === null || _q === void 0 ? void 0 : _q.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');
            return;
        }
        if (hasNextMessages && !isFetching.current.next) {
            try {
                isFetching.current.prev = true;
                const params = {
                    prevResultSize: 0,
                    nextResultSize: nextFetchSize,
                    isInclusive: false,
                    includeReactions: (_r = internalOptions.current.isReactionEnabled) !== null && _r !== void 0 ? _r : false,
                };
                const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(latestMessageTimeStamp, params);
                updateHasNextMessages(threadedMessages.length >= nextFetchSize);
                updateMessages(threadedMessages, false, (_s = sdk.currentUser) === null || _s === void 0 ? void 0 : _s.userId);
            }
            catch (error) {
                (_t = logger === null || logger === void 0 ? void 0 : logger.error) === null || _t === void 0 ? void 0 : _t.call(logger, '[useGroupChannelThreadMessages] loadNext thread list failed.', error);
            }
            finally {
                isFetching.current.next = false;
            }
        }
    }));
    const hasNext = usePreservedCallback(() => {
        return hasNextMessages;
    });
    const sendUserMessage = usePreservedCallback((params, onPending) => {
        var _a;
        if (!channelRef.current || !channelRef.current.url) {
            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve, reject) => {
            channelRef.current
                .sendUserMessage(params)
                .onPending((pendingMessage) => {
                var _a;
                if (pendingMessage.channelUrl === channelRef.current.url) {
                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
            })
                .onSucceeded((sentMessage) => {
                var _a;
                if (sentMessage.channelUrl === channelRef.current.url) {
                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                resolve(sentMessage);
            })
                .onFailed((err, failedMessage) => {
                var _a;
                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {
                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                reject(err);
            });
        });
    });
    const sendFileMessage = usePreservedCallback((params, onPending) => {
        var _a;
        if (!channelRef.current || !channelRef.current.url) {
            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve, reject) => {
            channelRef.current
                .sendFileMessage(params)
                .onPending((pendingMessage) => {
                var _a;
                if (pendingMessage.channelUrl === channelRef.current.url) {
                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
            })
                .onSucceeded((sentMessage) => {
                var _a;
                if (sentMessage.channelUrl === channelRef.current.url) {
                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                resolve(sentMessage);
            })
                .onFailed((err, failedMessage) => {
                var _a;
                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {
                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                reject(err);
            });
        });
    });
    const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {
        var _u;
        if (!channelRef.current || !channelRef.current.url) {
            (_u = logger === null || logger === void 0 ? void 0 : logger.error) === null || _u === void 0 ? void 0 : _u.call(logger, '[useGroupChannelThreadMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve) => {
            const messages = [];
            channelRef.current
                .sendFileMessages(paramsList)
                .onPending((pendingMessage) => {
                var _a;
                if (pendingMessage.channelUrl === channelRef.current.url) {
                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
            })
                .onSucceeded((sentMessage) => {
                var _a;
                if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {
                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                    messages.push(sentMessage);
                }
                if (messages.length === paramsList.length)
                    resolve(messages);
            })
                .onFailed((_, failedMessage) => {
                var _a;
                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {
                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                    messages.push(failedMessage);
                }
                else {
                    // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.
                    messages.push(null);
                }
                if (messages.length === paramsList.length)
                    resolve(messages);
            });
        });
    }));
    const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {
        var _a;
        if (!channelRef.current || !channelRef.current.url) {
            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve, reject) => {
            channelRef.current
                .sendMultipleFilesMessage(params)
                .onPending((pendingMessage) => {
                var _a;
                if (pendingMessage.channelUrl === channelRef.current.url) {
                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
            })
                .onFileUploaded(() => {
                // Just re-render to use updated message.messageParams
                forceUpdate();
            })
                .onSucceeded((sentMessage) => {
                var _a;
                if (sentMessage.channelUrl === channelRef.current.url) {
                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                resolve(sentMessage);
            })
                .onFailed((err, failedMessage) => {
                var _a;
                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {
                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                reject(err);
            });
        });
    });
    const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {
        var _v, _w;
        if (!channelRef.current || !channelRef.current.url) {
            (_v = logger === null || logger === void 0 ? void 0 : logger.error) === null || _v === void 0 ? void 0 : _v.call(logger, '[useGroupChannelThreadMessages] channel is required');
            throw new Error('Channel is required');
        }
        const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);
        if (updatedMessage.channelUrl === channelRef.current.url &&
            isThreadedMessage(updatedMessage, parentMessageRef.current)) {
            updateMessages([updatedMessage], false, (_w = sdk.currentUser) === null || _w === void 0 ? void 0 : _w.userId);
        }
        return updatedMessage;
    }));
    const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {
        var _x, _y;
        if (!channelRef.current || !channelRef.current.url) {
            (_x = logger === null || logger === void 0 ? void 0 : logger.error) === null || _x === void 0 ? void 0 : _x.call(logger, '[useGroupChannelThreadMessages] channel is required');
            throw new Error('Channel is required');
        }
        const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);
        if (updatedMessage.channelUrl === channelRef.current.url &&
            isThreadedMessage(updatedMessage, parentMessageRef.current)) {
            updateMessages([updatedMessage], false, (_y = sdk.currentUser) === null || _y === void 0 ? void 0 : _y.userId);
        }
        return updatedMessage;
    }));
    const resendMessage = usePreservedCallback((failedMessage) => __awaiter(void 0, void 0, void 0, function* () {
        var _z;
        if (!channelRef.current || !channelRef.current.url) {
            (_z = logger === null || logger === void 0 ? void 0 : logger.error) === null || _z === void 0 ? void 0 : _z.call(logger, '[useGroupChannelThreadMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve, reject) => {
            let handler = undefined;
            if (failedMessage.isUserMessage())
                handler = channelRef.current.resendMessage(failedMessage);
            if (failedMessage.isFileMessage())
                handler = channelRef.current.resendMessage(failedMessage);
            if (failedMessage.isMultipleFilesMessage())
                handler = channelRef.current.resendMessage(failedMessage);
            if (handler) {
                if ('onPending' in handler) {
                    handler.onPending((message) => {
                        var _a;
                        if (message.channelUrl === channelRef.current.url) {
                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                        }
                    });
                }
                if ('onFileUploaded' in handler) {
                    handler.onFileUploaded(() => {
                        // Just re-render to use updated message.messageParams
                        forceUpdate();
                    });
                }
                if ('onSucceeded' in handler) {
                    handler.onSucceeded((message) => {
                        var _a;
                        if (message.channelUrl === channelRef.current.url) {
                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                        }
                        resolve(message);
                    });
                }
                if ('onFailed' in handler) {
                    handler.onFailed((err, message) => {
                        var _a;
                        if (message && message.channelUrl === channelRef.current.url) {
                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                        }
                        reject(err);
                    });
                }
            }
        });
    }));
    const deleteMessage = usePreservedCallback((message) => __awaiter(void 0, void 0, void 0, function* () {
        var _0, _1;
        if (!channelRef.current || !channelRef.current.url) {
            (_0 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _0 === void 0 ? void 0 : _0.call(logger, '[useGroupChannelThreadMessages] channel is required');
            throw new Error('Channel is required');
        }
        if (message.sendingStatus === 'succeeded') {
            if (message.isUserMessage())
                yield channelRef.current.deleteMessage(message);
            if (message.isFileMessage())
                yield channelRef.current.deleteMessage(message);
            if (message.isMultipleFilesMessage())
                yield channelRef.current.deleteMessage(message);
        }
        else {
            try {
                yield ((_1 = collectionRef.current.instance) === null || _1 === void 0 ? void 0 : _1.removeFailedMessage(message.reqId));
            }
            finally {
                deleteMessages([message.messageId], [message.reqId]);
            }
        }
    }));
    const resetNewMessages = usePreservedCallback(() => {
        var _a;
        updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
    });
    const resetWithStartingPoint = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {
        var _2;
        if (sdk.currentUser && channelRef.current) {
            updateLoading(true);
            updateMessages([], true, (_2 = sdk.currentUser) === null || _2 === void 0 ? void 0 : _2.userId);
            yield init(startingPoint);
            updateLoading(false);
        }
    }));
    return {
        /**
         * Initialized state, only available on first render
         * */
        initialized,
        /**
         * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.
         * */
        loading,
        /**
         * Refreshing state, status is changes when the refresh is called.
         * */
        refreshing,
        /**
         * Get messages, this state is for render
         * For example, if a user receives a new messages while searching for an old message
         * for this case, new messages will be included here.
         * */
        messages,
        /**
         * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.
         * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)
         *
         * A new message means a message that meets the below conditions
         * - Not admin message
         * - Not updated message
         * - Not current user's message
         * */
        newMessages,
        /**
         * Reset new message list
         * @return {void}
         * */
        resetNewMessages,
        /**
         * Reset message list and create a new collection for latest messages
         * @return {Promise<void>}
         * */
        refresh,
        /**
         * Load previous messages to state
         * @return {Promise<void>}
         * */
        loadPrevious,
        /**
         * Check if there are more previous messages to fetch
         * @return {boolean}
         * */
        hasPrevious,
        /**
         * Load next messages to state
         * @return {Promise<void>}
         * */
        loadNext,
        /**
         * Check if there are more next messages to fetch
         * @return {boolean}
         * */
        hasNext,
        /**
         * Send user message
         * @param {UserMessageCreateParams} params user message create params
         * @param {function} [onPending] pending message callback
         * @return {Promise<UserMessage>} succeeded message
         * */
        sendUserMessage,
        /**
         * Send file message
         * @param {FileMessageCreateParams} params file message create params
         * @param {function} [onPending] pending message callback
         * @return {Promise<FileMessage>} succeeded message
         * */
        sendFileMessage,
        /**
         * Send file messages
         * @param {FileMessageCreateParams[]} paramList file message create params
         * @param {function} [onPending] pending message callback for each message request
         * @return {Promise<FileMessage[]>} succeeded or failed message
         * */
        sendFileMessages,
        /**
         * Send multiple files message
         * @param {MultipleFilesMessageCreateParams} params multiple files message create params
         * @param {function} [onPending] pending message callback
         * @return {Promise<MultipleFilesMessage>} succeeded message
         * */
        sendMultipleFilesMessage,
        /**
         * Update user message
         * @param {number} messageId
         * @param {UserMessageUpdateParams} params user message update params
         * @return {Promise<UserMessage>}
         * */
        updateUserMessage,
        /**
         * Update file message
         * @param {number} messageId
         * @param {FileMessageUpdateParams} params file message update params
         * @return {Promise<FileMessage>}
         * */
        updateFileMessage,
        /**
         * Resend failed message
         * @template {UserMessage | FileMessage | MultipleFilesMessage} T
         * @param {T} failedMessage message to resend
         * @return {Promise<T>}
         * */
        resendMessage,
        /**
         * Delete a message
         * @template {UserMessage | FileMessage | MultipleFilesMessage} T
         * @param {T} message succeeded or failed message
         * @return {Promise<void>}
         * */
        deleteMessage,
        /**
         * Reset message list and create a new collection with starting point
         * @param {number} startingPoint
         * @param {function} callback
         * @return {void}
         * */
        resetWithStartingPoint,
    };
};
