var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { useMemo, useReducer } from 'react';
import { SendingStatus } from '@sendbird/chat/message';
import { arrayToMapWithGetter } from '../../utils/convertors.js';
import { getMessageUniqId, isNewMessage, isSendableMessage } from '../../utils/message.js';
const defaultReducer = (_a, action) => {
    var draft = __rest(_a, []);
    switch (action.type) {
        case 'update_initialized': {
            draft['initialized'] = action.value.status;
            return draft;
        }
        case 'update_refreshing': {
            draft['refreshing'] = action.value.status;
            return draft;
        }
        case 'update_loading': {
            draft['loading'] = action.value.status;
            return draft;
        }
        case 'update_messages': {
            if (action.value.clearBeforeAction) {
                draft['messageMap'] = messagesToObject(action.value.messages);
            }
            else {
                const draftMessageMap = Object.assign({}, draft['messageMap']);
                const messagesToDelete = [];
                const messagesToAdd = [];
                action.value.messages.forEach((next) => {
                    const requestId = isSendableMessage(next) ? next.reqId : undefined;
                    const messageId = next.messageId || undefined;
                    [requestId, messageId].forEach((id) => {
                        if (!id)
                            return;
                        const prev = draftMessageMap[id];
                        if (shouldUpdateMessage(prev, next)) {
                            prev && messagesToDelete.push(prev);
                            messagesToAdd.push(next);
                        }
                    });
                });
                // Remove existing messages before update to prevent duplicate display
                messagesToDelete.forEach((it) => {
                    if (isSendableMessage(it))
                        delete draftMessageMap[it.reqId];
                    delete draftMessageMap[it.messageId];
                });
                messagesToAdd.forEach((it) => {
                    if (isSendableMessage(it))
                        draftMessageMap[it.reqId] = it;
                    draftMessageMap[it.messageId] = it;
                });
                draft['messageMap'] = draftMessageMap;
            }
            return draft;
        }
        case 'update_new_messages': {
            const userId = action.value.currentUserId;
            const newMessages = action.value.messages.filter((it) => isNewMessage(it, userId));
            if (action.value.clearBeforeAction) {
                draft['newMessageMap'] = arrayToMapWithGetter(newMessages, getMessageUniqId);
            }
            else {
                // Remove existing messages before update to prevent duplicate display
                const messageKeys = newMessages.map((it) => it.messageId);
                messageKeys.forEach((key) => delete draft['newMessageMap'][key]);
                draft['newMessageMap'] = Object.assign(Object.assign({}, draft['newMessageMap']), arrayToMapWithGetter(newMessages, getMessageUniqId));
            }
            return draft;
        }
        case 'delete_messages':
        case 'delete_new_messages': {
            const key = action.type === 'delete_messages' ? 'messageMap' : 'newMessageMap';
            draft[key] = Object.assign({}, draft[key]);
            action.value.messageIds.forEach((msgId) => {
                const message = draft[key][msgId];
                if (message) {
                    if (isSendableMessage(message))
                        delete draft[key][message.reqId];
                    delete draft[key][message.messageId];
                }
            });
            action.value.reqIds.forEach((reqId) => {
                const message = draft[key][reqId];
                if (message) {
                    if (isSendableMessage(message))
                        delete draft[key][message.reqId];
                    delete draft[key][message.messageId];
                }
            });
            return draft;
        }
    }
};
const messagesToObject = (messages) => {
    return messages.reduce((accum, curr) => {
        if (isSendableMessage(curr)) {
            accum[curr.reqId] = curr;
            if (curr.sendingStatus === SendingStatus.SUCCEEDED) {
                accum[curr.messageId] = curr;
            }
        }
        else {
            accum[curr.messageId] = curr;
        }
        return accum;
    }, {});
};
const shouldUpdateMessage = (prev, next) => {
    if (!isSendableMessage(prev) || !isSendableMessage(next))
        return true;
    // message data update (e.g. reactions)
    if (prev.sendingStatus === SendingStatus.SUCCEEDED)
        return next.sendingStatus === SendingStatus.SUCCEEDED;
    // message sending status update
    return prev.sendingStatus !== next.sendingStatus;
};
export const useChannelMessagesReducer = (sortComparator = defaultMessageComparator) => {
    const [{ initialized, loading, refreshing, messageMap, newMessageMap }, dispatch] = useReducer(defaultReducer, {
        initialized: false,
        loading: true,
        refreshing: false,
        messageMap: {},
        newMessageMap: {},
    });
    const updateMessages = (messages, clearBeforeAction, currentUserId) => {
        dispatch({ type: 'update_messages', value: { messages, clearBeforeAction, currentUserId } });
    };
    const deleteMessages = (messageIds, reqIds) => {
        dispatch({ type: 'delete_messages', value: { messageIds, reqIds } });
    };
    const updateNewMessages = (messages, clearBeforeAction, currentUserId) => {
        dispatch({ type: 'update_new_messages', value: { messages, clearBeforeAction, currentUserId } });
    };
    const deleteNewMessages = (messageIds, reqIds) => {
        dispatch({ type: 'delete_new_messages', value: { messageIds, reqIds } });
    };
    const updateInitialized = (status) => {
        dispatch({ type: 'update_initialized', value: { status } });
    };
    const updateLoading = (status) => {
        dispatch({ type: 'update_loading', value: { status } });
    };
    const updateRefreshing = (status) => {
        dispatch({ type: 'update_refreshing', value: { status } });
    };
    const newMessages = Object.values(newMessageMap);
    const messages = useMemo(() => Array.from(new Set(Object.values(messageMap))).sort(sortComparator), [messageMap]);
    return {
        updateInitialized,
        updateLoading,
        updateRefreshing,
        updateMessages,
        deleteMessages,
        initialized,
        loading,
        refreshing,
        messages,
        newMessages,
        updateNewMessages,
        deleteNewMessages,
    };
};
const LARGE_OFFSET = Math.floor(Number.MAX_SAFE_INTEGER / 10);
export function defaultMessageComparator(a, b) {
    let aStatusOffset = 0;
    let bStatusOffset = 0;
    if (isSendableMessage(a) && a.sendingStatus !== 'succeeded')
        aStatusOffset = LARGE_OFFSET;
    if (isSendableMessage(b) && b.sendingStatus !== 'succeeded')
        bStatusOffset = LARGE_OFFSET;
    return a.createdAt + aStatusOffset - (b.createdAt + bStatusOffset);
}
