var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { useEffect, useLayoutEffect, useRef } from 'react';
import { CollectionEventSource } from '@sendbird/chat';
import { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';
import { sbuConstants } from '../../constants/sbuConstants.js';
import { isDifferentChannel } from '../../utils/channel.js';
import { isMyMessage, isSendableMessage } from '../../utils/message.js';
import { isNotEmptyArray } from '../../utils/validators.js';
import { useForceUpdate } from '../useForceUpdate.js';
import { useGroupChannelHandler } from '../useGroupChannelHandler.js';
import { usePreservedCallback } from '../usePreservedCallback.js';
import { useChannelMessagesReducer } from './reducer.js';
const createMessageCollection = (channel, limit, options) => {
    var _a;
    const basicParams = {
        prevResultLimit: limit.prev,
        nextResultLimit: limit.next,
        startingPoint: options === null || options === void 0 ? void 0 : options.startingPoint,
        replyType: options === null || options === void 0 ? void 0 : options.replyType,
    };
    const passedCollection = (_a = options === null || options === void 0 ? void 0 : options.collectionCreator) === null || _a === void 0 ? void 0 : _a.call(options, basicParams);
    if (passedCollection)
        return passedCollection;
    return channel.createMessageCollection(Object.assign(Object.assign({}, basicParams), { filter: new MessageFilter(basicParams) }));
};
// NOTE: In React-Native's FlatList, the bidirectional message loading doesn't work reliably, causing a bug
//  where scrolling jumps to a random position when loading a large number of messages at once.
//  Therefore, in the message search that explores past messages, a small number of messages is loaded to address this issue.
function getCollectionLimitBy(startingPoint) {
    return startingPoint < Date.now()
        ? sbuConstants.collection.message.searchLimit
        : sbuConstants.collection.message.defaultLimit;
}
/**
 * group channel messages hook
 * - Receive new messages from other users & should count new messages -> append to state(newMessages)
 * - onTopReached -> prev() -> fetch prev messages and append to state(messages)
 * - onBottomReached -> next() -> fetch next messages and append to state(messages)
 * */
export const useGroupChannelMessages = (sdk, channel, options = {}) => {
    var _a, _b, _c;
    const internalOptions = useRef(options); // to keep reference of options in event handler
    internalOptions.current = options;
    const channelRef = useRef(channel); // to keep reference of channel in event handler
    channelRef.current = channel;
    const logger = internalOptions.current.logger;
    const initialStartingPoint = (_a = internalOptions.current.startingPoint) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER;
    const initialLimit = getCollectionLimitBy(initialStartingPoint);
    const isFetching = useRef({ prev: false, next: false });
    const forceUpdate = useForceUpdate();
    const collectionRef = useRef({
        initialized: false,
        apiInitialized: false,
        instance: null,
    });
    const { initialized, loading, refreshing, messages, newMessages, updateMessages, updateNewMessages, deleteNewMessages, deleteMessages, updateInitialized, updateLoading, updateRefreshing, } = useChannelMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);
    const markAsReadBySource = usePreservedCallback((source) => {
        var _a, _b, _c, _d;
        if (!channelRef.current || !channelRef.current.url)
            return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');
        try {
            switch (source) {
                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:
                case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:
                case CollectionEventSource.SYNC_MESSAGE_FILL:
                case undefined:
                    (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);
                    break;
            }
        }
        catch (e) {
            (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelMessages/markAsReadBySource]', e);
        }
    });
    const updateNewMessagesReceived = usePreservedCallback((source, messages) => {
        var _a, _b, _c, _d, _e;
        const incomingMessages = messages.filter((it) => { var _a; return !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId); });
        if (incomingMessages.length > 0) {
            switch (source) {
                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:
                case CollectionEventSource.SYNC_MESSAGE_FILL: {
                    if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {
                        updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
                    }
                    (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);
                    break;
                }
            }
        }
    });
    const init = usePreservedCallback((startingPoint, limit) => __awaiter(void 0, void 0, void 0, function* () {
        return new Promise((resolve) => {
            var _a, _b;
            if (!channelRef.current || !channelRef.current.url)
                return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');
            if (collectionRef.current.instance)
                collectionRef.current.instance.dispose();
            markAsReadBySource();
            updateNewMessages([], true, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);
            const updateUnsentMessages = () => {
                var _a, _b, _c;
                const { pendingMessages, failedMessages } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};
                if (isNotEmptyArray(pendingMessages))
                    updateMessages(pendingMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);
                if (isNotEmptyArray(failedMessages))
                    updateMessages(failedMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
            };
            const collectionInstance = createMessageCollection(channelRef.current, limit, Object.assign(Object.assign({}, internalOptions.current), { startingPoint }));
            collectionRef.current = { apiInitialized: false, initialized: false, instance: collectionInstance };
            collectionInstance.setMessageCollectionHandler({
                onMessagesAdded: (ctx, __, messages) => {
                    var _a;
                    markAsReadBySource(ctx.source);
                    updateNewMessagesReceived(ctx.source, messages);
                    updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                },
                onMessagesUpdated: (ctx, __, messages) => {
                    var _a, _b, _c;
                    markAsReadBySource(ctx.source);
                    updateNewMessagesReceived(ctx.source, messages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.
                    updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                    if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {
                        (_c = (_b = internalOptions.current).onMessagesUpdated) === null || _c === void 0 ? void 0 : _c.call(_b, messages);
                    }
                },
                onMessagesDeleted: (_, __, ___, messages) => {
                    const msgIds = messages.map((it) => it.messageId);
                    const reqIds = messages.filter(isSendableMessage).map((it) => it.reqId);
                    deleteMessages(msgIds, reqIds);
                    deleteNewMessages(msgIds, reqIds);
                },
                onChannelDeleted: (_, channelUrl) => {
                    var _a, _b;
                    (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);
                },
                onChannelUpdated: (_, channel) => {
                    var _a, _b;
                    forceUpdate();
                    (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);
                },
                onHugeGapDetected: () => {
                    init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);
                },
            });
            collectionInstance
                .initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API)
                .onCacheResult((err, messages) => {
                var _a, _b, _c;
                if (err)
                    sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onCacheResult]', err));
                else if (messages) {
                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onCacheResult]', 'message length:', messages.length);
                    updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
                    updateUnsentMessages();
                    // Note: If there are messages exchanged in the channel but no cached messages have been saved yet,
                    //  to prevent the API-retrieved messages from appearing immediately after the 'no messages' UI is displayed,
                    //  resolve only when there are messages present in the cache
                    if (messages.length > 0) {
                        collectionRef.current.initialized = true;
                        resolve();
                    }
                }
            })
                .onApiResult((err, messages) => {
                var _a, _b, _c, _d, _e;
                if (err)
                    (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onApiResult]', err);
                else if (messages) {
                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onApiResult]', 'message length:', messages.length);
                    updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);
                    if (!internalOptions.current.startingPoint)
                        (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, messages);
                    if (sdk.isCacheEnabled)
                        updateUnsentMessages();
                }
                collectionRef.current.initialized = true;
                collectionRef.current.apiInitialized = true;
                resolve();
            });
        });
    }));
    useGroupChannelHandler(sdk, {
        onUserBanned(eventChannel, bannedUser) {
            var _a, _b, _c;
            if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {
                if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {
                    (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);
                }
                else {
                    forceUpdate();
                }
            }
        },
    });
    useLayoutEffect(() => {
        const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
            if (sdk.currentUser && channelRef.current) {
                updateInitialized(false);
                updateLoading(true);
                yield init(initialStartingPoint, initialLimit);
                updateLoading(false);
                updateInitialized(true);
            }
        }));
        return () => clearTimeout(timeout);
    }, [sdk, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId, (_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.replyType]);
    useEffect(() => {
        return () => {
            if (collectionRef.current.instance)
                collectionRef.current.instance.dispose();
        };
    }, []);
    const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        if (sdk.currentUser && channelRef.current) {
            updateRefreshing(true);
            yield init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);
            updateRefreshing(false);
        }
    }));
    const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        var _d;
        const collection = collectionRef.current.instance;
        if ((collection === null || collection === void 0 ? void 0 : collection.hasPrevious) && !isFetching.current.prev) {
            try {
                isFetching.current.prev = true;
                const list = yield collection.loadPrevious();
                updateMessages(list, false, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId);
            }
            catch (_e) {
                // noop
            }
            finally {
                isFetching.current.prev = false;
            }
        }
    }));
    const hasPrevious = usePreservedCallback(() => {
        const { initialized, instance } = collectionRef.current;
        if (initialized && instance) {
            return instance.hasPrevious;
        }
        else {
            return false;
        }
    });
    const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {
        var _f;
        const collection = collectionRef.current.instance;
        if ((collection === null || collection === void 0 ? void 0 : collection.hasNext) && !isFetching.current.next) {
            try {
                isFetching.current.next = true;
                const list = yield collection.loadNext();
                updateMessages(list, false, (_f = sdk.currentUser) === null || _f === void 0 ? void 0 : _f.userId);
            }
            catch (_g) {
                // noop
            }
            finally {
                isFetching.current.next = false;
            }
        }
    }));
    const hasNext = usePreservedCallback(() => {
        // When the API is not initialized, the default value of collection.hasNext is true.
        // Due to this, there is an issue with UI elements such as the scroll to bottom button appearing and disappearing.
        // To address this, we additionally check the API initialized state.
        const { initialized, apiInitialized, instance } = collectionRef.current;
        if (apiInitialized && initialized && instance) {
            return instance.hasNext;
        }
        else {
            return false;
        }
    });
    const sendUserMessage = usePreservedCallback((params, onPending) => {
        var _a;
        if (!channelRef.current || !channelRef.current.url) {
            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve, reject) => {
            channelRef.current
                .sendUserMessage(params)
                .onPending((pendingMessage) => {
                var _a;
                if (pendingMessage.channelUrl === channelRef.current.url) {
                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
            })
                .onSucceeded((sentMessage) => {
                var _a;
                if (sentMessage.channelUrl === channelRef.current.url) {
                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                resolve(sentMessage);
            })
                .onFailed((err, failedMessage) => {
                var _a;
                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {
                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                reject(err);
            });
        });
    });
    const sendFileMessage = usePreservedCallback((params, onPending) => {
        var _a;
        if (!channelRef.current || !channelRef.current.url) {
            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve, reject) => {
            channelRef.current
                .sendFileMessage(params)
                .onPending((pendingMessage) => {
                var _a;
                if (pendingMessage.channelUrl === channelRef.current.url) {
                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
            })
                .onSucceeded((sentMessage) => {
                var _a;
                if (sentMessage.channelUrl === channelRef.current.url) {
                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                resolve(sentMessage);
            })
                .onFailed((err, failedMessage) => {
                var _a;
                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {
                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                reject(err);
            });
        });
    });
    const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {
        var _h;
        if (!channelRef.current || !channelRef.current.url) {
            (_h = logger === null || logger === void 0 ? void 0 : logger.error) === null || _h === void 0 ? void 0 : _h.call(logger, '[useGroupChannelMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve) => {
            const messages = [];
            channelRef.current
                .sendFileMessages(paramsList)
                .onPending((pendingMessage) => {
                var _a;
                if (pendingMessage.channelUrl === channelRef.current.url) {
                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
            })
                .onSucceeded((sentMessage) => {
                var _a;
                if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {
                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                    messages.push(sentMessage);
                }
                if (messages.length === paramsList.length)
                    resolve(messages);
            })
                .onFailed((_, failedMessage) => {
                var _a;
                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {
                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                    messages.push(failedMessage);
                }
                else {
                    // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.
                    messages.push(null);
                }
                if (messages.length === paramsList.length)
                    resolve(messages);
            });
        });
    }));
    const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {
        var _a;
        if (!channelRef.current || !channelRef.current.url) {
            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve, reject) => {
            channelRef.current
                .sendMultipleFilesMessage(params)
                .onPending((pendingMessage) => {
                var _a;
                if (pendingMessage.channelUrl === channelRef.current.url) {
                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);
            })
                .onFileUploaded(() => {
                // Just re-render to use updated message.messageParams
                forceUpdate();
            })
                .onSucceeded((sentMessage) => {
                var _a;
                if (sentMessage.channelUrl === channelRef.current.url) {
                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                resolve(sentMessage);
            })
                .onFailed((err, failedMessage) => {
                var _a;
                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {
                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                }
                reject(err);
            });
        });
    });
    const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {
        var _j, _k;
        if (!channelRef.current || !channelRef.current.url) {
            (_j = logger === null || logger === void 0 ? void 0 : logger.error) === null || _j === void 0 ? void 0 : _j.call(logger, '[useGroupChannelMessages] channel is required');
            throw new Error('Channel is required');
        }
        const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);
        if (updatedMessage.channelUrl === channelRef.current.url) {
            updateMessages([updatedMessage], false, (_k = sdk.currentUser) === null || _k === void 0 ? void 0 : _k.userId);
        }
        return updatedMessage;
    }));
    const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {
        var _l, _m;
        if (!channelRef.current || !channelRef.current.url) {
            (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelMessages] channel is required');
            throw new Error('Channel is required');
        }
        const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);
        if (updatedMessage.channelUrl === channelRef.current.url) {
            updateMessages([updatedMessage], false, (_m = sdk.currentUser) === null || _m === void 0 ? void 0 : _m.userId);
        }
        return updatedMessage;
    }));
    const resendMessage = usePreservedCallback((failedMessage) => __awaiter(void 0, void 0, void 0, function* () {
        var _o;
        if (!channelRef.current || !channelRef.current.url) {
            (_o = logger === null || logger === void 0 ? void 0 : logger.error) === null || _o === void 0 ? void 0 : _o.call(logger, '[useGroupChannelMessages] channel is required');
            throw new Error('Channel is required');
        }
        return new Promise((resolve, reject) => {
            let handler = undefined;
            if (failedMessage.isUserMessage())
                handler = channelRef.current.resendMessage(failedMessage);
            if (failedMessage.isFileMessage())
                handler = channelRef.current.resendMessage(failedMessage);
            if (failedMessage.isMultipleFilesMessage())
                handler = channelRef.current.resendMessage(failedMessage);
            if (handler) {
                if ('onPending' in handler) {
                    handler.onPending((message) => {
                        var _a;
                        if (message.channelUrl === channelRef.current.url) {
                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                        }
                    });
                }
                if ('onFileUploaded' in handler) {
                    handler.onFileUploaded(() => {
                        // Just re-render to use updated message.messageParams
                        forceUpdate();
                    });
                }
                if ('onSucceeded' in handler) {
                    handler.onSucceeded((message) => {
                        var _a;
                        if (message.channelUrl === channelRef.current.url) {
                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                        }
                        resolve(message);
                    });
                }
                if ('onFailed' in handler) {
                    handler.onFailed((err, message) => {
                        var _a;
                        if (message && message.channelUrl === channelRef.current.url) {
                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
                        }
                        reject(err);
                    });
                }
            }
        });
    }));
    const deleteMessage = usePreservedCallback((message) => __awaiter(void 0, void 0, void 0, function* () {
        var _p, _q;
        if (!channelRef.current || !channelRef.current.url) {
            (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelMessages] channel is required');
            throw new Error('Channel is required');
        }
        if (message.sendingStatus === 'succeeded') {
            if (message.isUserMessage())
                yield channelRef.current.deleteMessage(message);
            if (message.isFileMessage())
                yield channelRef.current.deleteMessage(message);
            if (message.isMultipleFilesMessage())
                yield channelRef.current.deleteMessage(message);
        }
        else {
            try {
                yield ((_q = collectionRef.current.instance) === null || _q === void 0 ? void 0 : _q.removeFailedMessage(message.reqId));
            }
            finally {
                deleteMessages([message.messageId], [message.reqId]);
            }
        }
    }));
    const resetNewMessages = usePreservedCallback(() => {
        var _a;
        updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);
    });
    const resetWithStartingPoint = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {
        var _r;
        if (sdk.currentUser && channelRef.current) {
            const limit = getCollectionLimitBy(startingPoint);
            updateLoading(true);
            updateMessages([], true, (_r = sdk.currentUser) === null || _r === void 0 ? void 0 : _r.userId);
            yield init(startingPoint, limit);
            updateLoading(false);
        }
    }));
    return {
        /**
         * Initialized state, only available on first render
         * */
        initialized,
        /**
         * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.
         * */
        loading,
        /**
         * Refreshing state, status is changes when the refresh is called.
         * */
        refreshing,
        /**
         * Get messages, this state is for render
         * For example, if a user receives a new messages while searching for an old message
         * for this case, new messages will be included here.
         * */
        messages,
        /**
         * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.
         * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)
         *
         * A new message means a message that meets the below conditions
         * - Not admin message
         * - Not updated message
         * - Not current user's message
         * */
        newMessages,
        /**
         * Reset new message list
         * @return {void}
         * */
        resetNewMessages,
        /**
         * Reset message list and create a new collection for latest messages
         * @return {Promise<void>}
         * */
        refresh,
        /**
         * Load previous messages to state
         * @return {Promise<void>}
         * */
        loadPrevious,
        /**
         * Check if there are more previous messages to fetch
         * @return {boolean}
         * */
        hasPrevious,
        /**
         * Load next messages to state
         * @return {Promise<void>}
         * */
        loadNext,
        /**
         * Check if there are more next messages to fetch
         * @return {boolean}
         * */
        hasNext,
        /**
         * Send user message
         * @param {UserMessageCreateParams} params user message create params
         * @param {function} [onPending] pending message callback
         * @return {Promise<UserMessage>} succeeded message
         * */
        sendUserMessage,
        /**
         * Send file message
         * @param {FileMessageCreateParams} params file message create params
         * @param {function} [onPending] pending message callback
         * @return {Promise<FileMessage>} succeeded message
         * */
        sendFileMessage,
        /**
         * Send file messages
         * @param {FileMessageCreateParams[]} paramList file message create params
         * @param {function} [onPending] pending message callback for each message request
         * @return {Promise<FileMessage[]>} succeeded or failed message
         * */
        sendFileMessages,
        /**
         * Send multiple files message
         * @param {MultipleFilesMessageCreateParams} params multiple files message create params
         * @param {function} [onPending] pending message callback
         * @return {Promise<MultipleFilesMessage>} succeeded message
         * */
        sendMultipleFilesMessage,
        /**
         * Update user message
         * @param {number} messageId
         * @param {UserMessageUpdateParams} params user message update params
         * @return {Promise<UserMessage>}
         * */
        updateUserMessage,
        /**
         * Update file message
         * @param {number} messageId
         * @param {FileMessageUpdateParams} params file message update params
         * @return {Promise<FileMessage>}
         * */
        updateFileMessage,
        /**
         * Resend failed message
         * @template {UserMessage | FileMessage | MultipleFilesMessage} T
         * @param {T} failedMessage message to resend
         * @return {Promise<T>}
         * */
        resendMessage,
        /**
         * Delete a message
         * @template {UserMessage | FileMessage | MultipleFilesMessage} T
         * @param {T} message succeeded or failed message
         * @return {Promise<void>}
         * */
        deleteMessage,
        /**
         * Reset message list and create a new collection with starting point
         * @param {number} startingPoint
         * @param {function} callback
         * @return {void}
         * */
        resetWithStartingPoint,
        /**
         * Do not use this api
         * */
        _dangerous_reducer_updateMessages: updateMessages,
        /**
         * Do not use this api
         * */
        _dangerous_reducer_deleteMessages: deleteMessages,
    };
};
