import { useEffect, useRef } from 'react';

import type { SendbirdChatWith } from '@sendbird/chat';
import type {
  GroupChannel,
  GroupChannelCollection,
  GroupChannelCollectionParams,
  GroupChannelFilterParams,
  GroupChannelModule,
} from '@sendbird/chat/groupChannel';
import { GroupChannelEventSource, GroupChannelFilter } from '@sendbird/chat/groupChannel';

import { premiumFeatures } from '../../constants/premiumFeatures.js';
import { sbuConstants } from '../../constants/sbuConstants.js';
import { useAsyncEffect } from '../useAsyncEffect.js';
import { useGroupChannelHandler } from '../useGroupChannelHandler.js';
import { usePreservedCallback } from '../usePreservedCallback.js';
import { useGroupChannelListReducer } from './reducer.js';

type CollectionCreatorBasicParams = Omit<GroupChannelCollectionParams, 'filter'> &
  Pick<GroupChannelFilterParams, 'includeEmpty'>;
type UseGroupChannelListOptions = {
  collectionCreator?: (basicParams: CollectionCreatorBasicParams) => GroupChannelCollection;
  markAsDelivered?: (channels: GroupChannel[]) => void;

  onChannelsAdded?: (channels: GroupChannel[]) => void;
  onChannelsUpdated?: (channels: GroupChannel[]) => void;
  onChannelsDeleted?: (channelUrls: string[]) => void;
};

const createGroupChannelListCollection = (
  sdk: SendbirdChatWith<[GroupChannelModule]>,
  collectionCreator: UseGroupChannelListOptions['collectionCreator'],
) => {
  const basicParams: CollectionCreatorBasicParams = {
    includeEmpty: sbuConstants.collection.groupChannel.defaultIncludeEmpty,
    limit: sbuConstants.collection.groupChannel.defaultLimit,
    order: sbuConstants.collection.groupChannel.defaultOrder,
  };

  const passedCollection = collectionCreator?.(basicParams);
  if (passedCollection) return passedCollection;

  return sdk.groupChannel.createGroupChannelCollection({
    ...basicParams,
    filter: new GroupChannelFilter(basicParams),
  });
};

export const useGroupChannelList = (
  sdk: SendbirdChatWith<[GroupChannelModule]>,
  options?: UseGroupChannelListOptions,
) => {
  const deliveryReceiptEnabled = Boolean(sdk.appInfo?.premiumFeatureList?.includes(premiumFeatures.delivery_receipt));
  const collectionRef = useRef<GroupChannelCollection>();

  // update reference for event handler
  const internalOptions = useRef(options);
  internalOptions.current = options;

  const {
    initialized,
    groupChannels,
    refreshing,
    appendChannels,
    deleteChannels,
    updateRefreshing,
    updateInitialized,
  } = useGroupChannelListReducer();

  const updateChannelsAndMarkAsDelivered = (
    shouldMarkAsDelivered: boolean,
    source?: GroupChannelEventSource,
    updatedChannels?: GroupChannel[],
  ) => {
    const channels = collectionRef.current?.channels ?? [];
    appendChannels(channels, true);

    if (shouldMarkAsDelivered && deliveryReceiptEnabled) {
      switch (source) {
        case GroupChannelEventSource.EVENT_MESSAGE_RECEIVED:
        case GroupChannelEventSource.EVENT_MESSAGE_SENT:
        case GroupChannelEventSource.SYNC_CHANNEL_BACKGROUND:
        case GroupChannelEventSource.SYNC_CHANNEL_CHANGELOGS:
        case undefined:
          internalOptions.current?.markAsDelivered?.(updatedChannels ?? channels);
          break;
      }
    }
  };

  const init = usePreservedCallback(async (uid?: string) => {
    if (collectionRef.current) collectionRef.current?.dispose();

    if (uid) {
      collectionRef.current = createGroupChannelListCollection(sdk, options?.collectionCreator);

      collectionRef.current?.setGroupChannelCollectionHandler({
        onChannelsAdded: (context, channels) => {
          const groupChannels = channels.filter((channel): channel is GroupChannel => channel.isGroupChannel());
          updateChannelsAndMarkAsDelivered(true, context.source, groupChannels);
          internalOptions.current?.onChannelsAdded?.(groupChannels);
        },
        onChannelsUpdated: (context, channels) => {
          const groupChannels = channels.filter((channel): channel is GroupChannel => channel.isGroupChannel());
          updateChannelsAndMarkAsDelivered(true, context.source, groupChannels);
          internalOptions.current?.onChannelsUpdated?.(groupChannels);
        },
        onChannelsDeleted: (_, channelUrls) => {
          updateChannelsAndMarkAsDelivered(false);
          internalOptions.current?.onChannelsDeleted?.(channelUrls);
        },
      });

      if (collectionRef.current?.hasMore) {
        await collectionRef.current?.loadMore();
        updateChannelsAndMarkAsDelivered(true);
      }
    }
  });

  useEffect(() => {
    return () => {
      if (collectionRef.current) collectionRef.current?.dispose();
    };
  }, []);

  useAsyncEffect(async () => {
    updateInitialized(false);
    if (sdk.currentUser) {
      await init(sdk.currentUser.userId);
      updateInitialized(true);
    }
  }, [sdk, sdk.currentUser?.userId]);

  useGroupChannelHandler(sdk, {
    onUserBanned: (channel, user) => {
      const isMe = user.userId === sdk.currentUser?.userId;
      if (isMe) {
        deleteChannels([channel.url]);
        internalOptions.current?.onChannelsDeleted?.([channel.url]);
      } else {
        updateChannelsAndMarkAsDelivered(false);
      }
    },
  });

  const refresh = usePreservedCallback(async () => {
    if (sdk.currentUser) {
      updateRefreshing(true);
      await init(sdk.currentUser.userId);
      updateRefreshing(false);
    }
  });

  const loadMore = usePreservedCallback(async () => {
    if (collectionRef.current?.hasMore) {
      await collectionRef.current?.loadMore();
      updateChannelsAndMarkAsDelivered(true);
    }
  });

  return {
    /**
     * Initializing state, only available on first render
     * */
    initialized,

    /**
     * Get group channels state
     * */
    groupChannels,

    /**
     * Refresh, clear and reload messages from latest
     * @return {Promise<void>}
     * */
    refresh,

    /**
     * Refreshing state, status is changes when the refresh is called.
     * */
    refreshing,

    /**
     * Fetch more channels to state
     * @return {Promise<void>}
     * */
    loadMore,
  };
};
