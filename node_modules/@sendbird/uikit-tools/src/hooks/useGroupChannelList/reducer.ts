import { useReducer } from 'react';

import type { BaseChannel } from '@sendbird/chat';
import type { GroupChannel } from '@sendbird/chat/groupChannel';

type Order = 'latest_last_message' | 'chronological' | 'channel_name_alphabetical' | 'metadata_value_alphabetical';

type Action =
  | {
      type: 'update_initialized' | 'update_refreshing';
      value: { status: boolean };
    }
  | {
      type: 'update_channels';
      value: { channels: BaseChannel[] };
    }
  | {
      type: 'delete_channels';
      value: { channelUrls: string[] };
    }
  | {
      type: 'append_channels';
      value: { channels: BaseChannel[]; clearBeforeAction: boolean };
    }
  | {
      type: 'update_order';
      value: { order?: Order };
    };

type State = {
  initialized: boolean;
  refreshing: boolean;
  groupChannels: GroupChannel[];
  order?: Order;
};

const defaultReducer = ({ ...draft }: State, action: Action) => {
  const compareByOrder = createCompareByOrder(draft.order);

  switch (action.type) {
    case 'update_refreshing': {
      draft.refreshing = action.value.status;
      break;
    }
    case 'update_initialized': {
      draft.initialized = action.value.status;
      break;
    }
    case 'update_channels': {
      getGroupChannels(action.value.channels).forEach((freshChannel) => {
        const idx = draft.groupChannels.findIndex((staleChannel) => staleChannel.url === freshChannel.url);
        if (idx > -1) draft.groupChannels[idx] = freshChannel;
      });

      compareByOrder && (draft.groupChannels = draft.groupChannels.sort(compareByOrder));
      break;
    }
    case 'delete_channels': {
      action.value.channelUrls.forEach((url) => {
        const idx = draft.groupChannels.findIndex((c) => c.url === url);
        if (idx > -1) draft.groupChannels.splice(idx, 1);
      });

      compareByOrder && (draft.groupChannels = draft.groupChannels.sort(compareByOrder));
      break;
    }
    case 'append_channels': {
      const groupChannels = getGroupChannels(action.value.channels);
      if (action.value.clearBeforeAction) {
        draft.groupChannels = groupChannels;
      } else {
        draft.groupChannels = mergeObjectArrays(draft.groupChannels, groupChannels, 'url');
      }

      compareByOrder && (draft.groupChannels = draft.groupChannels.sort(compareByOrder));
      break;
    }
    case 'update_order': {
      draft.order = action.value.order;
      const compareByOrder = createCompareByOrder(draft.order);
      compareByOrder && (draft.groupChannels = draft.groupChannels.sort(compareByOrder));
      break;
    }
  }
  return draft;
};

export const useGroupChannelListReducer = (order?: Order) => {
  const [{ initialized, refreshing, groupChannels }, dispatch] = useReducer(defaultReducer, {
    initialized: false,
    refreshing: false,
    groupChannels: [],
    order,
  });

  const updateChannels = (channels: BaseChannel[]) => {
    dispatch({ type: 'update_channels', value: { channels } });
  };
  const deleteChannels = (channelUrls: string[]) => {
    dispatch({ type: 'delete_channels', value: { channelUrls } });
  };
  const appendChannels = (channels: BaseChannel[], clearBeforeAction: boolean) => {
    dispatch({ type: 'append_channels', value: { channels, clearBeforeAction } });
  };
  const updateInitialized = (status: boolean) => {
    dispatch({ type: 'update_initialized', value: { status } });
  };
  const updateRefreshing = (status: boolean) => {
    dispatch({ type: 'update_refreshing', value: { status } });
  };
  const updateOrder = (order?: Order) => {
    dispatch({ type: 'update_order', value: { order } });
  };

  return {
    updateInitialized,
    updateRefreshing,
    updateChannels,
    deleteChannels,
    appendChannels,

    updateOrder,

    initialized,
    refreshing,
    groupChannels,
  };
};

const createCompareByOrder = (order?: Order) => {
  if (!order) return undefined;

  return (channel1: GroupChannel, channel2: GroupChannel): number => {
    switch (order) {
      case 'latest_last_message': {
        if (channel1.lastMessage && channel2.lastMessage) {
          return channel2.lastMessage.createdAt - channel1.lastMessage.createdAt;
        } else if (channel1.lastMessage) {
          return -1;
        } else if (channel2.lastMessage) {
          return 1;
        } else {
          return channel2.createdAt - channel1.createdAt;
        }
      }

      case 'chronological': {
        return channel2.createdAt - channel1.createdAt;
      }

      case 'channel_name_alphabetical': {
        return channel1.name.localeCompare(channel2.name);
      }
      default: {
        return 0;
      }
    }
  };
};

function mergeObjectArrays<T>(A: T[], B: T[], key: keyof T): T[] {
  const uniqueValues = new Set(A.map((obj) => obj[key]));
  const newArr = [...A];

  for (let i = 0; i < B.length; i++) {
    if (!uniqueValues.has(B[i][key])) {
      newArr.push(B[i]);
      uniqueValues.add(B[i][key]);
    }
  }

  return newArr;
}

function getGroupChannels(channels: BaseChannel[]): GroupChannel[] {
  return channels.filter((it): it is GroupChannel => it.isGroupChannel());
}
