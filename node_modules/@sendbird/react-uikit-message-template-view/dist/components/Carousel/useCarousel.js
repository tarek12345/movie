import React, { useLayoutEffect, useMemo, useRef, useState } from 'react';
const SWIPE_THRESHOLD = 24;
export function useCarousel({ spacing, childrenLength, paddingInlineStart, paddingInlineEnd }) {
    // TODO: RTL support
    const paddingStart = paddingInlineStart;
    const paddingEnd = paddingInlineEnd;
    const carouselRef = useRef(null);
    const childrenRefs = useRef(Array.from({ length: childrenLength }, () => React.createRef()));
    const isDragging = useRef(false);
    const isScrolling = useRef(false);
    const animationFrame = useRef(null);
    const drag = useRef({
        sx: null,
        sy: null,
        offset: 0,
        translateX: 0,
        currentIndex: 0,
    });
    const [childWidths, setChildWidths] = useState(() => childrenRefs.current.map(() => 0));
    const itemPositions = useMemo(() => {
        let currentPosition = paddingStart;
        return childWidths.map((width, i) => {
            const start = currentPosition - (i > 0 ? spacing : 0);
            const end = start - width;
            currentPosition = end;
            return { start, end };
        });
    }, [childWidths, spacing, paddingStart]);
    const totalContentWidth = useMemo(() => {
        const totalItemWidth = childWidths.reduce((acc, width) => acc + width, 0);
        const totalSpacing = spacing * (childrenLength - 1);
        return totalItemWidth + totalSpacing;
    }, [childWidths, spacing, childrenLength]);
    useLayoutEffect(() => {
        setChildWidths(childrenRefs.current.map((ref) => { var _a, _b; return (_b = (_a = ref.current) === null || _a === void 0 ? void 0 : _a.clientWidth) !== null && _b !== void 0 ? _b : 0; }));
    }, [childrenLength]);
    useLayoutEffect(() => {
        if (itemPositions.length > 0) {
            drag.current.translateX = itemPositions[0].start;
            animate();
        }
    }, [itemPositions]);
    const dragStart = () => {
        if (!carouselRef.current)
            return;
        isDragging.current = true;
        carouselRef.current.style.cursor = 'grabbing';
        carouselRef.current.style.transition = 'none';
        animationFrame.current = requestAnimationFrame(animate);
    };
    const dragStop = () => {
        if (!carouselRef.current)
            return;
        isDragging.current = false;
        carouselRef.current.style.cursor = 'grab';
        carouselRef.current.style.transition = 'transform 0.5s ease';
        if (animationFrame.current) {
            cancelAnimationFrame(animationFrame.current);
            animationFrame.current = null;
        }
    };
    const dragRelease = () => {
        const { offset, currentIndex } = drag.current;
        const thresholdExceeded = Math.abs(offset) >= SWIPE_THRESHOLD;
        const swipeToNext = offset < 0 && currentIndex < childrenLength - 1;
        const swipeToPrev = offset > 0 && currentIndex > 0;
        let newIndex = currentIndex;
        if (thresholdExceeded && swipeToNext) {
            newIndex = currentIndex + 1;
        }
        else if (thresholdExceeded && swipeToPrev) {
            newIndex = currentIndex - 1;
        }
        function clampTranslateX(translateX) {
            var _a, _b;
            const containerWidth = (_b = (_a = carouselRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth) !== null && _b !== void 0 ? _b : 0;
            const start = paddingStart;
            const end = Math.min(0, containerWidth - totalContentWidth) - paddingEnd;
            return Math.min(start, Math.max(end, translateX));
        }
        drag.current.currentIndex = newIndex;
        drag.current.translateX = clampTranslateX(itemPositions[newIndex].start);
        drag.current.offset = 0;
    };
    const scrollStart = () => {
        isScrolling.current = true;
    };
    const scrollStop = () => {
        isScrolling.current = false;
    };
    const animate = () => {
        if (carouselRef.current) {
            carouselRef.current.style.transform = `translateX(${drag.current.translateX + drag.current.offset}px)`;
        }
        if (animationFrame.current) {
            animationFrame.current = requestAnimationFrame(animate);
        }
    };
    const blockScroll = () => {
        if (carouselRef.current) {
            carouselRef.current.style.touchAction = 'pan-x';
        }
    };
    const unblockScroll = () => {
        if (carouselRef.current) {
            carouselRef.current.style.touchAction = 'pan-y';
        }
    };
    const onMouseDown = (event) => {
        dragStart();
        scrollStop();
        drag.current.sx = event.clientX;
        drag.current.sy = event.clientY;
        drag.current.offset = 0;
        animationFrame.current = requestAnimationFrame(animate);
    };
    const onMouseMove = (event) => {
        if (!isDragging.current || drag.current.sx === null)
            return;
        drag.current.offset = event.clientX - drag.current.sx;
    };
    const onMouseUp = () => {
        if (!isDragging.current)
            return;
        scrollStop();
        dragRelease();
        dragStop();
    };
    const onMouseLeave = () => {
        if (!isDragging.current)
            return;
        scrollStop();
        dragRelease();
        dragStop();
    };
    const onTouchStart = (event) => {
        scrollStop();
        dragStop();
        const touch = event.touches[0];
        drag.current.sx = touch.clientX;
        drag.current.sy = touch.clientY;
        drag.current.offset = 0;
        animationFrame.current = requestAnimationFrame(animate);
    };
    const onTouchMove = (event) => {
        if (drag.current.sx === null || drag.current.sy === null || isScrolling.current)
            return;
        const { clientX, clientY } = event.touches[0];
        const { sx, sy } = drag.current;
        if (isDragging.current) {
            drag.current.offset = clientX - sx;
            return;
        }
        const isVerticalScroll = Math.abs(clientY - sy) > Math.abs(clientX - sx);
        if (isVerticalScroll) {
            scrollStart();
        }
        else {
            drag.current.offset = clientX - sx;
            blockScroll();
            dragStart();
        }
    };
    const onTouchEnd = () => {
        unblockScroll();
        scrollStop();
        dragRelease();
        dragStop();
    };
    return {
        carouselRef,
        childrenRefs,
        handlers: {
            onMouseDown,
            onMouseMove,
            onMouseUp,
            onMouseLeave,
            onTouchStart,
            onTouchMove,
            onTouchEnd,
        },
    };
}
