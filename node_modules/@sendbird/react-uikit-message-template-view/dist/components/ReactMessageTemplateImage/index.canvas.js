var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useEffect, useMemo, useRef, useState } from 'react';
export const CanvasReactMessageTemplateImage = (props) => {
    const { imageSize, canvasRef, canvasProps } = useCanvasMessageTemplateImage(props);
    return (React.createElement("canvas", Object.assign({}, canvasProps, { ref: canvasRef, width: imageSize === null || imageSize === void 0 ? void 0 : imageSize.width, height: imageSize === null || imageSize === void 0 ? void 0 : imageSize.height, onError: props.onError })));
};
const useCanvasMessageTemplateImage = (_a) => {
    var { metaData, tintColor } = _a, props = __rest(_a, ["metaData", "tintColor"]);
    const canvasRef = useRef(null);
    const [fallbackImageSize, setFallbackImageSize] = useState();
    const imageSize = useMemo(() => {
        if ((metaData === null || metaData === void 0 ? void 0 : metaData.pixelHeight) && (metaData === null || metaData === void 0 ? void 0 : metaData.pixelWidth)) {
            return { width: metaData.pixelWidth, height: metaData.pixelHeight };
        }
        return fallbackImageSize;
    }, [fallbackImageSize, metaData === null || metaData === void 0 ? void 0 : metaData.pixelHeight, metaData === null || metaData === void 0 ? void 0 : metaData.pixelWidth]);
    useEffect(() => {
        if (imageSize == null) {
            console.log('Canvas_ReactMessageTemplateImage: no metaData, render fit to container');
            if (canvasRef.current) {
                canvasRef.current.style.width = '100%';
                canvasRef.current.style.height = '100%';
                const containerSize = canvasRef.current.getBoundingClientRect();
                setFallbackImageSize(containerSize);
            }
        }
    }, [imageSize]);
    useEffect(() => {
        if (props.src) {
            const img = new Image();
            const onImageLoad = () => {
                if (canvasRef.current && tintColor && imageSize) {
                    const ctx = canvasRef.current.getContext('2d');
                    if (ctx) {
                        const { width: imageWidth, height: imageHeight } = imageSize;
                        // reset context before draw, consider `.save()` and `.restore()` api
                        ctx.clearRect(0, 0, imageWidth, imageHeight);
                        ctx.beginPath();
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.fillStyle = '#000';
                        // draw
                        ctx.drawImage(img, 0, 0, imageWidth, imageHeight);
                        ctx.globalCompositeOperation = 'source-atop';
                        ctx.fillStyle = tintColor;
                        ctx.fillRect(0, 0, imageWidth, imageHeight);
                    }
                }
            };
            const onImageError = (event) => {
                var _a;
                // @ts-ignore
                (_a = props.onError) === null || _a === void 0 ? void 0 : _a.call(props, event);
            };
            img.addEventListener('load', onImageLoad);
            img.addEventListener('error', onImageError);
            img.src = props.src;
            return () => {
                img.removeEventListener('load', onImageLoad);
                img.removeEventListener('error', onImageError);
            };
        }
        return;
    }, [props.src, imageSize, tintColor]);
    return {
        canvasRef,
        canvasProps: props,
        imageSize,
    };
};
