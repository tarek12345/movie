var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { useEffect, useMemo } from 'react';
import { Layout, defaultProperties, useSizeContext } from '@sendbird/uikit-message-template';
import { isSizeCompatibleWithOption } from '../util';
import { useElementSize } from './useElementSize';
function isViewCompatibleWithSizeOption({ width = defaultProperties.view.size.width, height = defaultProperties.view.size.height, parentLayout = defaultProperties.box.layout, option, }) {
    if (parentLayout === Layout.Row) {
        return isSizeCompatibleWithOption({
            size: width,
            option,
        });
    }
    return isSizeCompatibleWithOption({
        size: height,
        option,
    });
}
export function useRecalculateWidth(params) {
    const { style, props } = params;
    const _a = useElementSize(), { ref: elemRef } = _a, size = __rest(_a, ["ref"]);
    const { updateSize, sizes } = useSizeContext();
    const { id, siblings, parentLayout } = props;
    const { width, height, paddingWidth, paddingHeight, contentWidth, contentHeight } = size;
    useEffect(() => {
        updateSize({
            id: props.id,
            width,
            height,
            paddingWidth,
            paddingHeight,
            contentWidth,
            contentHeight,
        });
    }, [props.id, width, height, paddingWidth, paddingHeight, contentWidth, contentHeight, updateSize]);
    const currentStyle = useMemo(() => {
        const sumViewSize = (acc = 0, view) => {
            var _a, _b, _c, _d;
            if (parentLayout === Layout.Row) {
                return acc + ((_b = (_a = sizes[view.id]) === null || _a === void 0 ? void 0 : _a.contentWidth) !== null && _b !== void 0 ? _b : 0);
            }
            return acc + ((_d = (_c = sizes[view.id]) === null || _c === void 0 ? void 0 : _c.contentHeight) !== null && _d !== void 0 ? _d : 0);
        };
        const hasFillOption = isViewCompatibleWithSizeOption({
            width: props.width,
            height: props.height,
            parentLayout,
            option: 'fill',
        });
        if (hasFillOption) {
            const wrapSiblingsSize = siblings
                .filter(({ width, height }) => !isViewCompatibleWithSizeOption({
                width: width,
                height: height,
                parentLayout,
                option: 'fill',
            }))
                .reduce(sumViewSize, 0);
            const fillSiblingCount = siblings.filter(({ width, height }) => isViewCompatibleWithSizeOption({
                width: width,
                height: height,
                parentLayout,
                option: 'fill',
            })).length;
            const maxSizeOption = (() => {
                if (parentLayout === Layout.Row) {
                    return {
                        maxWidth: `calc((100% - ${wrapSiblingsSize}px) / ${fillSiblingCount})`,
                    };
                }
                return {
                    maxHeight: `calc((100% - ${wrapSiblingsSize}px) / ${fillSiblingCount})`,
                };
            })();
            return Object.assign(Object.assign(Object.assign({}, style), maxSizeOption), (width == 0 && { height: 0 }));
        }
        else {
            const currentElemIdx = siblings.findIndex((sibling) => sibling.id === id);
            const forwardSiblingsSize = siblings
                .slice(0, currentElemIdx)
                .filter(({ width, height }) => isViewCompatibleWithSizeOption({
                width: width,
                height: height,
                parentLayout,
                option: 'wrap',
            }))
                .reduce(sumViewSize, 0);
            return Object.assign(Object.assign(Object.assign({}, style), (width === 0 && { height: 0 })), (parentLayout === Layout.Row
                ? {
                    maxWidth: `calc(100% - ${forwardSiblingsSize}px)`,
                }
                : {
                    maxHeight: `calc(100% - ${forwardSiblingsSize}px)`,
                }));
        }
    }, [props.width, props.height, parentLayout, sizes, siblings, style, width, id]);
    return { recalculatedStyle: currentStyle, elemRef };
}
