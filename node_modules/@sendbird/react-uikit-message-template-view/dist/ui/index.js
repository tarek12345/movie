import React from 'react';
import { FlexSizeSpecValue, Layout, createMessageTemplate, createParser, createRenderer, defaultProperties, } from '@sendbird/uikit-message-template';
import { Carousel } from '../components/Carousel';
import ReactMessageTemplateImage from '../components/ReactMessageTemplateImage';
import '../index.css';
import { getDefaultStyles, setAlign, setImageAspectRatio, setImageStyle, setTextAlign, setTextStyle, setViewProps, webkitLineClampStyles, } from '../styles';
import { ActionHandler } from './ActionHandler';
/**
 * Text that is fixed or fill parent should be wrapped in a div with max-width: 100% and max-height: 100%
 * This is to prevent text from overflowing the padding of the container
 */
function isFixedOrFill(view) {
    var _a, _b, _c, _d;
    const heightType = (_a = view === null || view === void 0 ? void 0 : view.height) === null || _a === void 0 ? void 0 : _a.type;
    const widthType = (_b = view === null || view === void 0 ? void 0 : view.width) === null || _b === void 0 ? void 0 : _b.type;
    const isFixedDiamension = heightType === 'fixed' || widthType === 'fixed';
    const isFill = (heightType === 'flex' && ((_c = view === null || view === void 0 ? void 0 : view.height) === null || _c === void 0 ? void 0 : _c.value) === FlexSizeSpecValue.FillParent) ||
        (widthType === 'flex' && ((_d = view === null || view === void 0 ? void 0 : view.width) === null || _d === void 0 ? void 0 : _d.value) === FlexSizeSpecValue.FillParent);
    return isFixedDiamension || isFill;
}
function convertNewlinesToBr(text) {
    return text.split('\n').map((line, index) => (React.createElement(React.Fragment, { key: index },
        line,
        React.createElement("br", null))));
}
function renderText(view) {
    const { text, maxTextLines } = view;
    const isToBeWrapped = isFixedOrFill(view);
    const hasMaxLines = typeof maxTextLines === 'number' && maxTextLines > 0;
    const convertedText = convertNewlinesToBr(text);
    if (hasMaxLines || isToBeWrapped) {
        const wrapperStyling = Object.assign(Object.assign({}, ((hasMaxLines || isToBeWrapped) && { maxWidth: '100%' })), (isToBeWrapped && { maxHeight: '100%', overflow: 'hidden' }));
        return (React.createElement("div", { style: wrapperStyling }, hasMaxLines ? React.createElement("div", { style: webkitLineClampStyles(maxTextLines) }, convertedText) : convertedText));
    }
    return hasMaxLines ? React.createElement("div", { style: webkitLineClampStyles(maxTextLines) }, convertedText) : convertedText;
}
export const renderer = createRenderer({
    views: {
        box(props) {
            return (React.createElement(ActionHandler, { className: "sb-message-template__box", elementId: props.elementId, style: props.parsedProperties, props: props }, props.children));
        },
        text(props) {
            return (React.createElement(ActionHandler, { className: "sb-message-template__text", elementId: props.elementId, style: props.parsedProperties, props: props }, renderText(props)));
        },
        image(props) {
            var _a;
            // todo: add image backup
            return (React.createElement(ActionHandler, { className: "sb-message-template__image-container", elementId: props.elementId, style: props.parsedProperties, props: props },
                React.createElement(ReactMessageTemplateImage, { className: "sb-message-template__image", alt: "image", src: props.imageUrl, style: { width: '100%', height: '100%', aspectRatio: 'inherit', objectFit: 'inherit' }, tintColor: (_a = props.imageStyle) === null || _a === void 0 ? void 0 : _a.tintColor, metaData: props.metaData })));
        },
        textButton(props) {
            return (React.createElement(ActionHandler, { className: "sb-message-template__text-button", elementId: props.elementId, style: props.parsedProperties, props: props }, renderText(Object.assign({ maxTextLines: defaultProperties.textButton.maxTextLines }, props))));
        },
        imageButton(props) {
            var _a;
            return (React.createElement(ActionHandler, { className: "sb-message-template__image-container sb-message-template__image-button", elementId: props.elementId, style: props.parsedProperties, props: props },
                React.createElement(ReactMessageTemplateImage, { className: "sb-message-template__image", alt: "image-button", src: props.imageUrl, style: { width: '100%', height: '100%', aspectRatio: 'inherit', objectFit: 'inherit' }, tintColor: (_a = props.imageStyle) === null || _a === void 0 ? void 0 : _a.tintColor, metaData: props.metaData })));
        },
        carouselView(props) {
            var _a, _b;
            return (React.createElement(Carousel, { maxChildWidth: (_a = props.carouselStyle) === null || _a === void 0 ? void 0 : _a.maxChildWidth, spacing: (_b = props.carouselStyle) === null || _b === void 0 ? void 0 : _b.spacing, style: props.parsedProperties }, props.children));
        },
    },
});
export const parser = createParser({
    mapBoxProps(props, options) {
        const styles = getDefaultStyles();
        setViewProps(styles, props, options);
        setAlign(styles, props.layout, props.align);
        return styles;
    },
    mapTextProps(props, options) {
        var _a;
        const styles = getDefaultStyles({ whiteSpace: 'pre-line', wordBreak: 'break-word' });
        // Better not set flex 1 to text
        setViewProps(styles, props, options);
        setTextStyle(styles, props, options);
        setAlign(styles, Layout.Row, props.align);
        setTextAlign(styles, (_a = props.align) === null || _a === void 0 ? void 0 : _a.horizontal);
        return styles;
    },
    mapImageProps(props, options) {
        const styles = getDefaultStyles();
        setViewProps(styles, props, options);
        setImageStyle(styles, props.imageStyle);
        setImageAspectRatio(styles, props);
        return styles;
    },
    mapTextButtonProps(props, options) {
        const styles = getDefaultStyles({ whiteSpace: 'pre-line', alignItems: 'center', justifyContent: 'center' });
        setViewProps(styles, props, options);
        setTextStyle(styles, props, options);
        return styles;
    },
    mapImageButtonProps(props, options) {
        const styles = getDefaultStyles();
        setViewProps(styles, props, options);
        setImageStyle(styles, props.imageStyle);
        setImageAspectRatio(styles, props);
        return styles;
    },
    mapCarouselProps(props, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const styles = getDefaultStyles();
        setViewProps(styles, props, options);
        styles['paddingBlockStart'] = (_b = (_a = props.viewStyle) === null || _a === void 0 ? void 0 : _a.padding) === null || _b === void 0 ? void 0 : _b.top;
        styles['paddingBlockEnd'] = (_d = (_c = props.viewStyle) === null || _c === void 0 ? void 0 : _c.padding) === null || _d === void 0 ? void 0 : _d.bottom;
        styles['paddingInlineStart'] = (_f = (_e = props.viewStyle) === null || _e === void 0 ? void 0 : _e.padding) === null || _f === void 0 ? void 0 : _f.left;
        styles['paddingInlineEnd'] = (_h = (_g = props.viewStyle) === null || _g === void 0 ? void 0 : _g.padding) === null || _h === void 0 ? void 0 : _h.right;
        return styles;
    },
});
export const { MessageTemplate } = createMessageTemplate({
    renderer,
    parser,
    Container: ({ children, className }) => {
        return (React.createElement("div", { className: `sb-message-template__parent ${className}`, style: {
                display: 'flex',
                flexDirection: 'column',
                maxWidth: 400,
                marginBlockEnd: 24,
            } }, children));
    },
});
