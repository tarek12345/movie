import React, { useEffect, useMemo, useRef, useState } from 'react';

import type { ReactMessageTemplateImageProps, Size } from './index';

export const CanvasReactMessageTemplateImage = (props: ReactMessageTemplateImageProps) => {
  const { imageSize, canvasRef, canvasProps } = useCanvasMessageTemplateImage(props);

  return (
    <canvas
      {...(canvasProps as any)}
      ref={canvasRef}
      width={imageSize?.width}
      height={imageSize?.height}
      onError={props.onError}
    />
  );
};

const useCanvasMessageTemplateImage = ({ metaData, tintColor, ...props }: ReactMessageTemplateImageProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [fallbackImageSize, setFallbackImageSize] = useState<Size>();

  const imageSize = useMemo(() => {
    if (metaData?.pixelHeight && metaData?.pixelWidth) {
      return { width: metaData.pixelWidth, height: metaData.pixelHeight };
    }
    return fallbackImageSize;
  }, [fallbackImageSize, metaData?.pixelHeight, metaData?.pixelWidth]);

  useEffect(() => {
    if (imageSize == null) {
      console.log('Canvas_ReactMessageTemplateImage: no metaData, render fit to container');

      if (canvasRef.current) {
        canvasRef.current.style.width = '100%';
        canvasRef.current.style.height = '100%';
        const containerSize = canvasRef.current.getBoundingClientRect();
        setFallbackImageSize(containerSize);
      }
    }
  }, [imageSize]);

  useEffect(() => {
    if (props.src) {
      const img = new Image();

      const onImageLoad = () => {
        if (canvasRef.current && tintColor && imageSize) {
          const ctx = canvasRef.current.getContext('2d');
          if (ctx) {
            const { width: imageWidth, height: imageHeight } = imageSize;

            // reset context before draw, consider `.save()` and `.restore()` api
            ctx.clearRect(0, 0, imageWidth, imageHeight);
            ctx.beginPath();
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = '#000';

            // draw
            ctx.drawImage(img, 0, 0, imageWidth, imageHeight);
            ctx.globalCompositeOperation = 'source-atop';
            ctx.fillStyle = tintColor;
            ctx.fillRect(0, 0, imageWidth, imageHeight);
          }
        }
      };
      const onImageError = (event: ErrorEvent) => {
        // @ts-ignore
        props.onError?.(event);
      };

      img.addEventListener('load', onImageLoad);
      img.addEventListener('error', onImageError);
      img.src = props.src;

      return () => {
        img.removeEventListener('load', onImageLoad);
        img.removeEventListener('error', onImageError);
      };
    }
    return;
  }, [props.src, imageSize, tintColor]);

  return {
    canvasRef,
    canvasProps: props,
    imageSize,
  };
};
