import { useEffect, useMemo } from 'react';

import { Layout, SizeSpec, View, defaultProperties, useSizeContext } from '@sendbird/uikit-message-template';

import type { ActionHandlerProps } from '../ui/ActionHandler';
import { isSizeCompatibleWithOption } from '../util';
import { useElementSize } from './useElementSize';

function isViewCompatibleWithSizeOption({
  width = defaultProperties.view.size.width,
  height = defaultProperties.view.size.height,
  parentLayout = defaultProperties.box.layout,
  option,
}: {
  width?: SizeSpec;
  height?: SizeSpec;
  parentLayout?: Layout;
  option: 'wrap' | 'fill' | 'fixed';
}) {
  if (parentLayout === Layout.Row) {
    return isSizeCompatibleWithOption({
      size: width,
      option,
    });
  }

  return isSizeCompatibleWithOption({
    size: height,
    option,
  });
}

export function useRecalculateWidth(params: Pick<ActionHandlerProps, 'props' | 'style'>) {
  const { style, props } = params;
  const { ref: elemRef, ...size } = useElementSize();
  const { updateSize, sizes } = useSizeContext();

  const { id, siblings, parentLayout } = props;

  const { width, height, paddingWidth, paddingHeight, contentWidth, contentHeight } = size;

  useEffect(() => {
    updateSize({
      id: props.id,
      width,
      height,
      paddingWidth,
      paddingHeight,
      contentWidth,
      contentHeight,
    });
  }, [props.id, width, height, paddingWidth, paddingHeight, contentWidth, contentHeight, updateSize]);

  const currentStyle = useMemo(() => {
    const sumViewSize = (acc = 0, view: View) => {
      if (parentLayout === Layout.Row) {
        return acc + (sizes[view.id as string]?.contentWidth ?? 0);
      }

      return acc + (sizes[view.id as string]?.contentHeight ?? 0);
    };

    const hasFillOption = isViewCompatibleWithSizeOption({
      width: props.width,
      height: props.height,
      parentLayout,
      option: 'fill',
    });

    if (hasFillOption) {
      const wrapSiblingsSize = siblings
        .filter(
          ({ width, height }) =>
            !isViewCompatibleWithSizeOption({
              width: width,
              height: height,
              parentLayout,
              option: 'fill',
            }),
        )
        .reduce(sumViewSize, 0);

      const fillSiblingCount = siblings.filter(({ width, height }) =>
        isViewCompatibleWithSizeOption({
          width: width,
          height: height,
          parentLayout,
          option: 'fill',
        }),
      ).length;

      const maxSizeOption = (() => {
        if (parentLayout === Layout.Row) {
          return {
            maxWidth: `calc((100% - ${wrapSiblingsSize}px) / ${fillSiblingCount})`,
          };
        }
        return {
          maxHeight: `calc((100% - ${wrapSiblingsSize}px) / ${fillSiblingCount})`,
        };
      })();

      return {
        ...style,
        ...maxSizeOption,
        ...(width == 0 && { height: 0 }),
      };
    } else {
      const currentElemIdx = siblings.findIndex((sibling) => sibling.id === id);
      const forwardSiblingsSize = siblings
        .slice(0, currentElemIdx)
        .filter(({ width, height }) =>
          isViewCompatibleWithSizeOption({
            width: width,
            height: height,
            parentLayout,
            option: 'wrap',
          }),
        )
        .reduce(sumViewSize, 0);

      return {
        ...style,
        // to hide any elements which's width is 0
        // This code is to hide when text is overflowed
        ...(width === 0 && { height: 0 }),
        ...(parentLayout === Layout.Row
          ? {
              maxWidth: `calc(100% - ${forwardSiblingsSize}px)`,
            }
          : {
              maxHeight: `calc(100% - ${forwardSiblingsSize}px)`,
            }),
      };
    }
  }, [props.width, props.height, parentLayout, sizes, siblings, style, width, id]);

  return { recalculatedStyle: currentStyle, elemRef };
}
